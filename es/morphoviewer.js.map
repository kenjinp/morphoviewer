{"version":3,"file":"morphoviewer.js","sources":["../src/thirdparty/TrackballControls.js","../src/thirdparty/STLLoader.js","../src/Tools.js","../src/EventManager.js","../src/thirdparty/LoaderSupport.js","../src/thirdparty/OBJLoader2.js","../src/ThreeContext.js","../src/thirdparty/QuickHull.js","../src/thirdparty/ConvexGeometry.js","../src/MorphologyShapeBase.js","../src/MorphologyPolyline.js","../src/thirdparty/BufferGeometryUtils.js","../src/MorphologyPolycylinder.js","../src/MorphoViewer.js","../src/main.js"],"sourcesContent":["/*\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin   / http://mark-lundin.com\n * @author Simone Manini / http://daron1337.github.io\n * @author Luca Antiga   / http://lantiga.github.io\n */\n\n\nimport * as THREE from 'three'\n\n/*\n* ES6 adapted source from the example folder of THREEJS (because there is no proper repo for it)\n* Enables mouse control (pan, zoom, rotation)\n*/\nconst TrackballControls = function (object, domElement) {\n  const _this = this\n  const STATE = {\n    NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4,\n  }\n\n  this.object = object\n  this.domElement = (domElement !== undefined) ? domElement : document\n\n  // API\n\n  this.enabled = true\n\n  this.screen = {\n    left: 0, top: 0, width: 0, height: 0,\n  }\n\n  this.rotateSpeed = 1.0\n  this.zoomSpeed = 1.2\n  this.panSpeed = 0.3\n\n  this.noRotate = false\n  this.noZoom = false\n  this.noPan = false\n\n  this.staticMoving = false\n  this.dynamicDampingFactor = 0.5\n\n  this.minDistance = 0\n  this.maxDistance = Infinity\n\n  this.keys = [65 /* A */, 83 /* S */, 68]\n\n  // internals\n\n  this.target = new THREE.Vector3()\n\n  const EPS = 0.000001\n\n  const lastPosition = new THREE.Vector3()\n\n  let _state = STATE.NONE\n\n\n  let _prevState = STATE.NONE\n\n\n  const _eye = new THREE.Vector3()\n\n\n  const _movePrev = new THREE.Vector2()\n\n\n  const _moveCurr = new THREE.Vector2()\n\n\n  const _lastAxis = new THREE.Vector3()\n\n\n  let _lastAngle = 0\n\n\n  const _zoomStart = new THREE.Vector2()\n\n\n  const _zoomEnd = new THREE.Vector2()\n\n\n  let _touchZoomDistanceStart = 0\n\n\n  let _touchZoomDistanceEnd = 0\n\n\n  const _panStart = new THREE.Vector2()\n\n\n  const _panEnd = new THREE.Vector2()\n\n  // for reset\n\n  this.target0 = this.target.clone()\n  this.position0 = this.object.position.clone()\n  this.up0 = this.object.up.clone()\n\n  // events\n\n  const changeEvent = { type: 'change' }\n  const startEvent = { type: 'start' }\n  const endEvent = { type: 'end' }\n\n\n  // methods\n\n  this.handleResize = function () {\n    if (this.domElement === document) {\n      this.screen.left = 0\n      this.screen.top = 0\n      this.screen.width = window.innerWidth\n      this.screen.height = window.innerHeight\n    } else {\n      const box = this.domElement.getBoundingClientRect()\n      // adjustments come from similar code in the jquery offset() function\n      const d = this.domElement.ownerDocument.documentElement\n      this.screen.left = box.left + window.pageXOffset - d.clientLeft\n      this.screen.top = box.top + window.pageYOffset - d.clientTop\n      this.screen.width = box.width\n      this.screen.height = box.height\n    }\n  }\n\n  const getMouseOnScreen = (function () {\n    const vector = new THREE.Vector2()\n\n    return function getMouseOnScreen(pageX, pageY) {\n      vector.set(\n        (pageX - _this.screen.left) / _this.screen.width,\n        (pageY - _this.screen.top) / _this.screen.height,\n      )\n\n      return vector\n    }\n  }())\n\n  const getMouseOnCircle = (function () {\n    const vector = new THREE.Vector2()\n\n    return function getMouseOnCircle(pageX, pageY) {\n      vector.set(\n        ((pageX - _this.screen.width * 0.5 - _this.screen.left) / (_this.screen.width * 0.5)),\n        ((_this.screen.height + 2 * (_this.screen.top - pageY)) / _this.screen.width), // screen.width intentional\n      )\n\n      return vector\n    }\n  }())\n\n  this.rotateCamera = (function () {\n    const axis = new THREE.Vector3()\n\n\n    const quaternion = new THREE.Quaternion()\n\n\n    const eyeDirection = new THREE.Vector3()\n\n\n    const objectUpDirection = new THREE.Vector3()\n\n\n    const objectSidewaysDirection = new THREE.Vector3()\n\n\n    const moveDirection = new THREE.Vector3()\n\n\n    let angle\n\n    return function rotateCamera() {\n      moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0)\n      angle = moveDirection.length()\n\n      if (angle) {\n        _eye.copy(_this.object.position).sub(_this.target)\n\n        eyeDirection.copy(_eye).normalize()\n        objectUpDirection.copy(_this.object.up).normalize()\n        objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize()\n\n        objectUpDirection.setLength(_moveCurr.y - _movePrev.y)\n        objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x)\n\n        moveDirection.copy(objectUpDirection.add(objectSidewaysDirection))\n\n        axis.crossVectors(moveDirection, _eye).normalize()\n\n        angle *= _this.rotateSpeed\n        quaternion.setFromAxisAngle(axis, angle)\n\n        _eye.applyQuaternion(quaternion)\n        _this.object.up.applyQuaternion(quaternion)\n\n        _lastAxis.copy(axis)\n        _lastAngle = angle\n      } else if (!_this.staticMoving && _lastAngle) {\n        _lastAngle *= Math.sqrt(1.0 - _this.dynamicDampingFactor)\n        _eye.copy(_this.object.position).sub(_this.target)\n        quaternion.setFromAxisAngle(_lastAxis, _lastAngle)\n        _eye.applyQuaternion(quaternion)\n        _this.object.up.applyQuaternion(quaternion)\n      }\n\n      _movePrev.copy(_moveCurr)\n    }\n  }())\n\n\n  this.zoomCamera = function () {\n    let factor\n\n    if (_state === STATE.TOUCH_ZOOM_PAN) {\n      factor = _touchZoomDistanceStart / _touchZoomDistanceEnd\n      _touchZoomDistanceStart = _touchZoomDistanceEnd\n      _eye.multiplyScalar(factor)\n    } else {\n      factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * _this.zoomSpeed\n\n      if (factor !== 1.0 && factor > 0.0) {\n        _eye.multiplyScalar(factor)\n      }\n\n      if (_this.staticMoving) {\n        _zoomStart.copy(_zoomEnd)\n      } else {\n        _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor\n      }\n    }\n  }\n\n  this.panCamera = (function () {\n    const mouseChange = new THREE.Vector2()\n\n\n    const objectUp = new THREE.Vector3()\n\n\n    const pan = new THREE.Vector3()\n\n    return function panCamera() {\n      mouseChange.copy(_panEnd).sub(_panStart)\n\n      if (mouseChange.lengthSq()) {\n        mouseChange.multiplyScalar(_eye.length() * _this.panSpeed)\n\n        pan.copy(_eye).cross(_this.object.up).setLength(mouseChange.x)\n        pan.add(objectUp.copy(_this.object.up).setLength(mouseChange.y))\n\n        _this.object.position.add(pan)\n        _this.target.add(pan)\n\n        if (_this.staticMoving) {\n          _panStart.copy(_panEnd)\n        } else {\n          _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(_this.dynamicDampingFactor))\n        }\n      }\n    }\n  }())\n\n  this.checkDistances = function () {\n    if (!_this.noZoom || !_this.noPan) {\n      if (_eye.lengthSq() > _this.maxDistance * _this.maxDistance) {\n        _this.object.position.addVectors(_this.target, _eye.setLength(_this.maxDistance))\n        _zoomStart.copy(_zoomEnd)\n      }\n\n      if (_eye.lengthSq() < _this.minDistance * _this.minDistance) {\n        _this.object.position.addVectors(_this.target, _eye.setLength(_this.minDistance))\n        _zoomStart.copy(_zoomEnd)\n      }\n    }\n  }\n\n  this.update = function () {\n    _eye.subVectors(_this.object.position, _this.target)\n\n    if (!_this.noRotate) {\n      _this.rotateCamera()\n    }\n\n    if (!_this.noZoom) {\n      _this.zoomCamera()\n    }\n\n    if (!_this.noPan) {\n      _this.panCamera()\n    }\n\n    _this.object.position.addVectors(_this.target, _eye)\n\n    _this.checkDistances()\n\n    _this.object.lookAt(_this.target)\n\n    if (lastPosition.distanceToSquared(_this.object.position) > EPS) {\n      _this.dispatchEvent(changeEvent)\n\n      lastPosition.copy(_this.object.position)\n    }\n  }\n\n  this.reset = function () {\n    _state = STATE.NONE\n    _prevState = STATE.NONE\n\n    _this.target.copy(_this.target0)\n    _this.object.position.copy(_this.position0)\n    _this.object.up.copy(_this.up0)\n\n    _eye.subVectors(_this.object.position, _this.target)\n\n    _this.object.lookAt(_this.target)\n\n    _this.dispatchEvent(changeEvent)\n\n    lastPosition.copy(_this.object.position)\n  }\n\n  // listeners\n\n  function keydown(event) {\n    if (_this.enabled === false) return\n\n    window.removeEventListener('keydown', keydown)\n\n    _prevState = _state\n\n    if (_state !== STATE.NONE) {\n      return\n    } if (event.keyCode === _this.keys[STATE.ROTATE] && !_this.noRotate) {\n      _state = STATE.ROTATE\n    } else if (event.keyCode === _this.keys[STATE.ZOOM] && !_this.noZoom) {\n      _state = STATE.ZOOM\n    } else if (event.keyCode === _this.keys[STATE.PAN] && !_this.noPan) {\n      _state = STATE.PAN\n    }\n  }\n\n  function keyup(event) {\n    if (_this.enabled === false) return\n\n    _state = _prevState\n\n    window.addEventListener('keydown', keydown, false)\n  }\n\n  function mousedown(event) {\n    if (_this.enabled === false) return\n\n    event.preventDefault()\n    event.stopPropagation()\n\n    if (_state === STATE.NONE) {\n      _state = event.button\n    }\n\n    if (_state === STATE.ROTATE && !_this.noRotate) {\n      _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY))\n      _movePrev.copy(_moveCurr)\n    } else if (_state === STATE.ZOOM && !_this.noZoom) {\n      _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY))\n      _zoomEnd.copy(_zoomStart)\n    } else if (_state === STATE.PAN && !_this.noPan) {\n      _panStart.copy(getMouseOnScreen(event.pageX, event.pageY))\n      _panEnd.copy(_panStart)\n    }\n\n    document.addEventListener('mousemove', mousemove, false)\n    document.addEventListener('mouseup', mouseup, false)\n\n    _this.dispatchEvent(startEvent)\n  }\n\n  function mousemove(event) {\n    if (_this.enabled === false) return\n\n    event.preventDefault()\n    event.stopPropagation()\n\n    if (_state === STATE.ROTATE && !_this.noRotate) {\n      _movePrev.copy(_moveCurr)\n      _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY))\n    } else if (_state === STATE.ZOOM && !_this.noZoom) {\n      _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY))\n    } else if (_state === STATE.PAN && !_this.noPan) {\n      _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY))\n    }\n  }\n\n  function mouseup(event) {\n    if (_this.enabled === false) return\n\n    event.preventDefault()\n    event.stopPropagation()\n\n    _state = STATE.NONE\n\n    document.removeEventListener('mousemove', mousemove)\n    document.removeEventListener('mouseup', mouseup)\n    _this.dispatchEvent(endEvent)\n  }\n\n  function mousewheel(event) {\n    if (_this.enabled === false) return\n\n    if (_this.noZoom === true) return\n\n    event.preventDefault()\n    event.stopPropagation()\n\n    switch (event.deltaMode) {\n      case 2:\n        // Zoom in pages\n        _zoomStart.y -= event.deltaY * 0.025\n        break\n\n      case 1:\n        // Zoom in lines\n        _zoomStart.y -= event.deltaY * 0.01\n        break\n\n      default:\n        // undefined, 0, assume pixels\n        _zoomStart.y -= event.deltaY * 0.00025\n        break\n    }\n\n    _this.dispatchEvent(startEvent)\n    _this.dispatchEvent(endEvent)\n  }\n\n  function touchstart(event) {\n    if (_this.enabled === false) return\n\n    event.preventDefault()\n\n    switch (event.touches.length) {\n      case 1:\n        _state = STATE.TOUCH_ROTATE\n        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY))\n        _movePrev.copy(_moveCurr)\n        break\n\n      default: // 2 or more\n        _state = STATE.TOUCH_ZOOM_PAN\n        var dx = event.touches[0].pageX - event.touches[1].pageX\n        var dy = event.touches[0].pageY - event.touches[1].pageY\n        _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy)\n\n        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2\n        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2\n        _panStart.copy(getMouseOnScreen(x, y))\n        _panEnd.copy(_panStart)\n        break\n    }\n\n    _this.dispatchEvent(startEvent)\n  }\n\n  function touchmove(event) {\n    if (_this.enabled === false) return\n\n    event.preventDefault()\n    event.stopPropagation()\n\n    switch (event.touches.length) {\n      case 1:\n        _movePrev.copy(_moveCurr)\n        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY))\n        break\n\n      default: // 2 or more\n        var dx = event.touches[0].pageX - event.touches[1].pageX\n        var dy = event.touches[0].pageY - event.touches[1].pageY\n        _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy)\n\n        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2\n        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2\n        _panEnd.copy(getMouseOnScreen(x, y))\n        break\n    }\n  }\n\n  function touchend(event) {\n    if (_this.enabled === false) return\n\n    switch (event.touches.length) {\n      case 0:\n        _state = STATE.NONE\n        break\n\n      case 1:\n        _state = STATE.TOUCH_ROTATE\n        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY))\n        _movePrev.copy(_moveCurr)\n        break\n    }\n\n    _this.dispatchEvent(endEvent)\n  }\n\n  function contextmenu(event) {\n    if (_this.enabled === false) return\n\n    event.preventDefault()\n  }\n\n  this.dispose = function () {\n    this.domElement.removeEventListener('contextmenu', contextmenu, false)\n    this.domElement.removeEventListener('mousedown', mousedown, false)\n    this.domElement.removeEventListener('wheel', mousewheel, false)\n\n    this.domElement.removeEventListener('touchstart', touchstart, false)\n    this.domElement.removeEventListener('touchend', touchend, false)\n    this.domElement.removeEventListener('touchmove', touchmove, false)\n\n    document.removeEventListener('mousemove', mousemove, false)\n    document.removeEventListener('mouseup', mouseup, false)\n\n    window.removeEventListener('keydown', keydown, false)\n    window.removeEventListener('keyup', keyup, false)\n  }\n\n  this.domElement.addEventListener('contextmenu', contextmenu, false)\n  this.domElement.addEventListener('mousedown', mousedown, false)\n  this.domElement.addEventListener('wheel', mousewheel, false)\n\n  this.domElement.addEventListener('touchstart', touchstart, false)\n  this.domElement.addEventListener('touchend', touchend, false)\n  this.domElement.addEventListener('touchmove', touchmove, false)\n\n  window.addEventListener('keydown', keydown, false)\n  window.addEventListener('keyup', keyup, false)\n\n  this.handleResize()\n\n  // force an update at start\n  this.update()\n}\n\n\nTrackballControls.prototype = Object.create(THREE.EventDispatcher.prototype)\n// TrackballControls.prototype.constructor = THREE.TrackballControls;\n\nexport default TrackballControls\n","/*\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\n\nimport pako from 'pako'\nimport * as THREE from 'three'\n\n\nconst STLLoader = function (manager) {\n  this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager\n}\n\nSTLLoader.prototype = {\n\n  constructor: STLLoader,\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new THREE.FileLoader(scope.manager)\n    loader.setResponseType('arraybuffer')\n    loader.load(url, (buf) => {\n      // trying to un-gzip it with Pako\n      try {\n        buf = pako.inflate(buf).buffer\n      } catch (err) {\n      }\n\n      try {\n        onLoad(scope.parse(buf))\n      } catch (exception) {\n        if (onError) {\n          onError(exception)\n        }\n      }\n    }, onProgress, onError)\n  },\n\n  parse(data) {\n    function isBinary(data) {\n      let expect; let face_size; let n_faces; let\n        reader\n      reader = new DataView(data)\n      face_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8)\n      n_faces = reader.getUint32(80, true)\n      expect = 80 + (32 / 8) + (n_faces * face_size)\n\n      if (expect === reader.byteLength) {\n        return true\n      }\n\n      // An ASCII STL data must begin with 'solid ' as the first six bytes.\n      // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n      // plentiful.  So, check the first 5 bytes for 'solid'.\n\n      // Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n      // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n      // Search for \"solid\" to start anywhere after those prefixes.\n\n      // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n      const solid = [115, 111, 108, 105, 100]\n\n      for (let off = 0; off < 5; off++) {\n        // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n        if (matchDataViewAt(solid, reader, off)) return false\n      }\n\n      // Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n      return true\n    }\n\n    function matchDataViewAt(query, reader, offset) {\n      // Check if each byte in query matches the corresponding byte from the current offset\n\n      for (let i = 0, il = query.length; i < il; i++) {\n        if (query[i] !== reader.getUint8(offset + i, false)) return false\n      }\n\n      return true\n    }\n\n    function parseBinary(data) {\n      const reader = new DataView(data)\n      const faces = reader.getUint32(80, true)\n\n      let r; let g; let b; let hasColors = false; let\n        colors\n      let defaultR; let defaultG; let defaultB; let\n        alpha\n\n      // process STL header\n      // check for default color in header (\"COLOR=rgba\" sequence).\n\n      for (let index = 0; index < 80 - 10; index++) {\n        if ((reader.getUint32(index, false) == 0x434F4C4F /* COLO */)\n          && (reader.getUint8(index + 4) == 0x52 /* 'R' */)\n          && (reader.getUint8(index + 5) == 0x3D /* '=' */)) {\n          hasColors = true\n          colors = []\n\n          defaultR = reader.getUint8(index + 6) / 255\n          defaultG = reader.getUint8(index + 7) / 255\n          defaultB = reader.getUint8(index + 8) / 255\n          alpha = reader.getUint8(index + 9) / 255\n        }\n      }\n\n      const dataOffset = 84\n      const faceLength = 12 * 4 + 2\n\n      const geometry = new THREE.BufferGeometry()\n\n      const vertices = []\n      const normals = []\n\n      for (let face = 0; face < faces; face++) {\n        const start = dataOffset + face * faceLength\n        const normalX = reader.getFloat32(start, true)\n        const normalY = reader.getFloat32(start + 4, true)\n        const normalZ = reader.getFloat32(start + 8, true)\n\n        if (hasColors) {\n          const packedColor = reader.getUint16(start + 48, true)\n\n          if ((packedColor & 0x8000) === 0) {\n            // facet has its own unique color\n\n            r = (packedColor & 0x1F) / 31\n            g = ((packedColor >> 5) & 0x1F) / 31\n            b = ((packedColor >> 10) & 0x1F) / 31\n          } else {\n            r = defaultR\n            g = defaultG\n            b = defaultB\n          }\n        }\n\n        for (let i = 1; i <= 3; i++) {\n          const vertexstart = start + i * 12\n\n          vertices.push(reader.getFloat32(vertexstart, true))\n          vertices.push(reader.getFloat32(vertexstart + 4, true))\n          vertices.push(reader.getFloat32(vertexstart + 8, true))\n\n          normals.push(normalX, normalY, normalZ)\n\n          if (hasColors) {\n            colors.push(r, g, b)\n          }\n        }\n      }\n\n      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3))\n      geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3))\n\n      if (hasColors) {\n        geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3))\n        geometry.hasColors = true\n        geometry.alpha = alpha\n      }\n\n      return geometry\n    }\n\n    function parseASCII(data) {\n      const geometry = new THREE.BufferGeometry()\n      const patternFace = /facet([\\s\\S]*?)endfacet/g\n      let faceCounter = 0\n\n      const patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source\n      const patternVertex = new RegExp(`vertex${patternFloat}${patternFloat}${patternFloat}`, 'g')\n      const patternNormal = new RegExp(`normal${patternFloat}${patternFloat}${patternFloat}`, 'g')\n\n      const vertices = []\n      const normals = []\n\n      const normal = new THREE.Vector3()\n\n      let result\n\n      while ((result = patternFace.exec(data)) !== null) {\n        let vertexCountPerFace = 0\n        let normalCountPerFace = 0\n\n        const text = result[0]\n\n        while ((result = patternNormal.exec(text)) !== null) {\n          normal.x = parseFloat(result[1])\n          normal.y = parseFloat(result[2])\n          normal.z = parseFloat(result[3])\n          normalCountPerFace++\n        }\n\n        while ((result = patternVertex.exec(text)) !== null) {\n          vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]))\n          normals.push(normal.x, normal.y, normal.z)\n          vertexCountPerFace++\n        }\n\n        // every face have to own ONE valid normal\n\n        if (normalCountPerFace !== 1) {\n          console.error(`THREE.STLLoader: Something isn't right with the normal of face number ${faceCounter}`)\n        }\n\n        // each face have to own THREE valid vertices\n\n        if (vertexCountPerFace !== 3) {\n          console.error(`THREE.STLLoader: Something isn't right with the vertices of face number ${faceCounter}`)\n        }\n\n        faceCounter++\n      }\n\n      geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n      geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3))\n\n      return geometry\n    }\n\n    function ensureString(buffer) {\n      if (typeof buffer !== 'string') {\n        return THREE.LoaderUtils.decodeText(new Uint8Array(buffer))\n      }\n\n      return buffer\n    }\n\n    function ensureBinary(buffer) {\n      if (typeof buffer === 'string') {\n        const array_buffer = new Uint8Array(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n          array_buffer[i] = buffer.charCodeAt(i) & 0xff // implicitly assumes little-endian\n        }\n        return array_buffer.buffer || array_buffer\n      }\n\n      return buffer\n    }\n\n    // start\n\n    const binData = ensureBinary(data)\n\n    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data))\n  },\n\n}\n\n\nexport default STLLoader\n","import * as THREE from 'three'\n\n/* global document */\n\n/**\n* Some handy static functions to do stuff that are not strictly related to the business of the project\n*/\nclass Tools {\n  /**\n   * Handy function to deal with option object we pass in argument of function.\n   * Allows the return of a default value if the `optionName` is not available in\n   * the `optionObj`\n   * @param {Object} optionObj - the object that contain the options\n   * @param {String} optionName - the name of the option desired, attribute of `optionObj`\n   * @param {any} optionDefaultValue - default values to be returned in case `optionName` is not an attribute of `optionObj`\n   */\n  static getOption(optionObj, optionName, optionDefaultValue) {\n    return (optionObj && optionName in optionObj) ? optionObj[optionName] : optionDefaultValue\n  }\n\n\n  /**\n   * @private\n   * Generate a cylinder with a starting point and en endpoint because\n   * THREEjs does not provide that\n   * @param {THREE.Vector3} vStart - the start position\n   * @param {THREE.Vector3} vEnd - the end position\n   * @param {Number} rStart - radius at the `vStart` position\n   * @param {Number} rEnd - radius at the `vEnd` position\n   * @param {Boolean} openEnd - cylinder has open ends if true, or closed ends if false\n   * @return {THREE.CylinderBufferGeometry} the mesh containing a cylinder\n   */\n  static makeCylinder(vStart, vEnd, rStart, rEnd, openEnd) {\n    const HALF_PI = Math.PI * 0.5\n    const distance = vStart.distanceTo(vEnd)\n    const position = vEnd.clone().add(vStart).divideScalar(2)\n\n    const offsetPosition = new THREE.Matrix4()// a matrix to fix pivot position\n    offsetPosition.setPosition(position)\n\n    const cylinder = new THREE.CylinderBufferGeometry(rStart, rEnd, distance, 8, 1, openEnd)\n    const orientation = new THREE.Matrix4()// a new orientation matrix to offset pivot\n    orientation.multiply(offsetPosition) // test to add offset\n    const offsetRotation = new THREE.Matrix4()// a matrix to fix pivot rotation\n    orientation.lookAt(vStart, vEnd, new THREE.Vector3(0, 1, 0))// look at destination\n    offsetRotation.makeRotationX(HALF_PI)// rotate 90 degs on X\n    orientation.multiply(offsetRotation)// combine orientation with rotation transformations\n    cylinder.applyMatrix(orientation)\n    return cylinder\n  }\n\n\n  static triggerDownload(strData, filename) {\n    const link = document.createElement('a')\n    document.body.appendChild(link) // Firefox requires the link to be in the body\n    link.download = filename\n    link.href = strData\n    link.click()\n    document.body.removeChild(link) // remove the link when done\n  }\n}\n\nexport default Tools\n","/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  MIT\n* Link     https://github.com/Pixpipe/quickvoxelcore\n* Lab      MCIN - Montreal Neurological Institute\n*/\n\n\n/**\n * The EventManager deals with events, create them, call them.\n * This class is mostly for being inherited from.\n */\nclass EventManager {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this._events = {}\n  }\n\n\n  /**\n   * Define an event, with a name associated with a function\n   * @param  {String} eventName - Name to give to the event\n   * @param  {Function} callback - function associated to the even\n   */\n  on(eventName, callback) {\n    if (typeof callback === 'function') {\n      if (!(eventName in this._events)) {\n        this._events[eventName] = []\n      }\n      this._events[eventName].push(callback)\n    } else {\n      console.warn('The callback must be of type Function')\n    }\n  }\n\n\n  emit(eventName, args = []) {\n    // the event must exist and be non null\n    if ((eventName in this._events) && (this._events[eventName].length > 0)) {\n      const events = this._events[eventName]\n      for (let i = 0; i < events.length; i += 1) {\n        events[i](...args)\n      }\n    } else {\n      console.warn(`No function associated to the event ${eventName}`)\n    }\n  }\n}\n\nexport default EventManager\n","/*\n  * @author Kai Salmen / https://kaisalmen.de\n  * Development repository: https://github.com/kaisalmen/WWOBJLoader\n  */\n\n\nlet LoaderSupport = {}\n\n/*\n * Validation functions.\n * @class\n */\nLoaderSupport.Validator = {\n  /*\n   * If given input is null or undefined, false is returned otherwise true.\n   *\n   * @param input Can be anything\n   * @returns {boolean}\n   */\n  isValid: function( input ) {\n    return ( input !== null && input !== undefined );\n  },\n  /*\n   * If given input is null or undefined, the defaultValue is returned otherwise the given input.\n   *\n   * @param input Can be anything\n   * @param defaultValue Can be anything\n   * @returns {*}\n   */\n  verifyInput: function( input, defaultValue ) {\n    return ( input === null || input === undefined ) ? defaultValue : input;\n  }\n};\n\n\n/*\n * Callbacks utilized by loaders and builders.\n * @class\n */\nLoaderSupport.Callbacks = (function () {\n\n  var Validator = LoaderSupport.Validator;\n\n  function Callbacks() {\n    this.onProgress = null;\n    this.onReportError = null;\n    this.onMeshAlter = null;\n    this.onLoad = null;\n    this.onLoadMaterials = null;\n  }\n\n  /*\n   * Register callback function that is invoked by internal function \"announceProgress\" to print feedback.\n   * @memberOf LoaderSupport.Callbacks\n   *\n   * @param {callback} callbackOnProgress Callback function for described functionality\n   */\n  Callbacks.prototype.setCallbackOnProgress = function ( callbackOnProgress ) {\n    this.onProgress = Validator.verifyInput( callbackOnProgress, this.onProgress );\n  };\n\n  /*\n   * Register callback function that is invoked when an error is reported.\n   * @memberOf LoaderSupport.Callbacks\n   *\n   * @param {callback} callbackOnReportError Callback function for described functionality\n   */\n  Callbacks.prototype.setCallbackOnReportError = function ( callbackOnReportError ) {\n    this.onReportError = Validator.verifyInput( callbackOnReportError, this.onReportError );\n  };\n\n  /*\n   * Register callback function that is called every time a mesh was loaded.\n   * Use {@link LoaderSupport.LoadedMeshUserOverride} for alteration instructions (geometry, material or disregard mesh).\n   * @memberOf LoaderSupport.Callbacks\n   *\n   * @param {callback} callbackOnMeshAlter Callback function for described functionality\n   */\n  Callbacks.prototype.setCallbackOnMeshAlter = function ( callbackOnMeshAlter ) {\n    this.onMeshAlter = Validator.verifyInput( callbackOnMeshAlter, this.onMeshAlter );\n  };\n\n  /*\n   * Register callback function that is called once loading of the complete OBJ file is completed.\n   * @memberOf LoaderSupport.Callbacks\n   *\n   * @param {callback} callbackOnLoad Callback function for described functionality\n   */\n  Callbacks.prototype.setCallbackOnLoad = function ( callbackOnLoad ) {\n    this.onLoad = Validator.verifyInput( callbackOnLoad, this.onLoad );\n  };\n\n  /*\n   * Register callback function that is called when materials have been loaded.\n   * @memberOf LoaderSupport.Callbacks\n   *\n   * @param {callback} callbackOnLoadMaterials Callback function for described functionality\n   */\n  Callbacks.prototype.setCallbackOnLoadMaterials = function ( callbackOnLoadMaterials ) {\n    this.onLoadMaterials = Validator.verifyInput( callbackOnLoadMaterials, this.onLoadMaterials );\n  };\n\n  return Callbacks;\n})();\n\n\n/*\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nLoaderSupport.LoadedMeshUserOverride = (function () {\n\n  function LoadedMeshUserOverride( disregardMesh, alteredMesh ) {\n    this.disregardMesh = disregardMesh === true;\n    this.alteredMesh = alteredMesh === true;\n    this.meshes = [];\n  }\n\n  /*\n   * Add a mesh created within callback.\n   *\n   * @memberOf THREE.OBJLoader2.LoadedMeshUserOverride\n   *\n   * @param {THREE.Mesh} mesh\n   */\n  LoadedMeshUserOverride.prototype.addMesh = function ( mesh ) {\n    this.meshes.push( mesh );\n    this.alteredMesh = true;\n  };\n\n  /*\n   * Answers if mesh shall be disregarded completely.\n   *\n   * @returns {boolean}\n   */\n  LoadedMeshUserOverride.prototype.isDisregardMesh = function () {\n    return this.disregardMesh;\n  };\n\n  /*\n   * Answers if new mesh(es) were created.\n   *\n   * @returns {boolean}\n   */\n  LoadedMeshUserOverride.prototype.providesAlteredMeshes = function () {\n    return this.alteredMesh;\n  };\n\n  return LoadedMeshUserOverride;\n})();\n\n\n/*\n * A resource description used by {@link LoaderSupport.PrepData} and others.\n * @class\n *\n * @param {string} url URL to the file\n * @param {string} extension The file extension (type)\n */\nLoaderSupport.ResourceDescriptor = (function () {\n\n  var Validator = LoaderSupport.Validator;\n\n  function ResourceDescriptor( url, extension ) {\n    var urlParts = url.split( '/' );\n\n    if ( urlParts.length < 2 ) {\n\n      this.path = null;\n      this.name = url;\n      this.url = url;\n\n    } else {\n\n      this.path = Validator.verifyInput( urlParts.slice( 0, urlParts.length - 1).join( '/' ) + '/', null );\n      this.name = urlParts[ urlParts.length - 1 ];\n      this.url = url;\n\n    }\n    this.name = Validator.verifyInput( this.name, 'Unnamed_Resource' );\n    this.extension = Validator.verifyInput( extension, 'default' );\n    this.extension = this.extension.trim();\n    this.content = null;\n  }\n\n  /*\n   * Set the content of this resource\n   * @memberOf LoaderSupport.ResourceDescriptor\n   *\n   * @param {Object} content The file content as arraybuffer or text\n   */\n  ResourceDescriptor.prototype.setContent = function ( content ) {\n    this.content = Validator.verifyInput( content, null );\n  };\n\n  return ResourceDescriptor;\n})();\n\n\n/*\n * Configuration instructions to be used by run method.\n * @class\n */\nLoaderSupport.PrepData = (function () {\n\n  var Validator = LoaderSupport.Validator;\n\n  function PrepData( modelName ) {\n    this.logging = {\n      enabled: true,\n      debug: false\n    };\n    this.modelName = Validator.verifyInput( modelName, '' );\n    this.resources = [];\n    this.callbacks = new LoaderSupport.Callbacks();\n  }\n\n  /*\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   * @memberOf LoaderSupport.PrepData\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   */\n  PrepData.prototype.setLogging = function ( enabled, debug ) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n  };\n\n  /*\n   * Returns all callbacks as {@link LoaderSupport.Callbacks}\n   * @memberOf LoaderSupport.PrepData\n   *\n   * @returns {LoaderSupport.Callbacks}\n   */\n  PrepData.prototype.getCallbacks = function () {\n    return this.callbacks;\n  };\n\n  /*\n   * Add a resource description.\n   * @memberOf LoaderSupport.PrepData\n   *\n   * @param {LoaderSupport.ResourceDescriptor} Adds a {@link LoaderSupport.ResourceDescriptor}\n   */\n  PrepData.prototype.addResource = function ( resource ) {\n    this.resources.push( resource );\n  };\n\n  /*\n   * Clones this object and returns it afterwards. Callbacks and resources are not cloned deep (references!).\n   * @memberOf LoaderSupport.PrepData\n   *\n   * @returns {@link LoaderSupport.PrepData}\n   */\n  PrepData.prototype.clone = function () {\n    var clone = new LoaderSupport.PrepData( this.modelName );\n    clone.logging.enabled = this.logging.enabled;\n    clone.logging.debug = this.logging.debug;\n    clone.resources = this.resources;\n    clone.callbacks = this.callbacks;\n\n    var property, value;\n    for ( property in this ) {\n\n      value = this[ property ];\n      if ( ! clone.hasOwnProperty( property ) && typeof this[ property ] !== 'function' ) {\n\n        clone[ property ] = value;\n\n      }\n    }\n\n    return clone;\n  };\n\n\n  /*\n   * Identify files or content of interest from an Array of {@link LoaderSupport.ResourceDescriptor}.\n   * @memberOf LoaderSupport.PrepData\n   *\n   * @param {LoaderSupport.ResourceDescriptor[]} resources Array of {@link LoaderSupport.ResourceDescriptor}\n   * @param Object fileDesc Object describing which resources are of interest (ext, type (string or UInt8Array) and ignore (boolean))\n   * @returns {{}} Object with each \"ext\" and the corresponding {@link LoaderSupport.ResourceDescriptor}\n   */\n  PrepData.prototype.checkResourceDescriptorFiles = function ( resources, fileDesc ) {\n    var resource, triple, i, found;\n    var result = {};\n\n    for ( var index in resources ) {\n\n      resource = resources[ index ];\n      found = false;\n      if ( ! Validator.isValid( resource.name ) ) continue;\n      if ( Validator.isValid( resource.content ) ) {\n\n        for ( i = 0; i < fileDesc.length && !found; i++ ) {\n\n          triple = fileDesc[ i ];\n          if ( resource.extension.toLowerCase() === triple.ext.toLowerCase() ) {\n\n            if ( triple.ignore ) {\n\n              found = true;\n\n            } else if ( triple.type === \"ArrayBuffer\" ) {\n\n              // fast-fail on bad type\n              if ( ! ( resource.content instanceof ArrayBuffer || resource.content instanceof Uint8Array ) ) throw 'Provided content is not of type ArrayBuffer! Aborting...';\n              result[ triple.ext ] = resource;\n              found = true;\n\n            } else if ( triple.type === \"String\" ) {\n\n              if ( ! ( typeof( resource.content ) === 'string' || resource.content instanceof String) ) throw 'Provided  content is not of type String! Aborting...';\n              result[ triple.ext ] = resource;\n              found = true;\n\n            }\n\n          }\n\n        }\n        if ( !found ) throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url;\n\n      } else {\n\n        // fast-fail on bad type\n        if ( ! ( typeof( resource.name ) === 'string' || resource.name instanceof String ) ) throw 'Provided file is not properly defined! Aborting...';\n        for ( i = 0; i < fileDesc.length && !found; i++ ) {\n\n          triple = fileDesc[ i ];\n          if ( resource.extension.toLowerCase() === triple.ext.toLowerCase() ) {\n\n            if ( ! triple.ignore ) result[ triple.ext ] = resource;\n            found = true;\n\n          }\n\n        }\n        if ( !found ) throw 'Unidentified resource \"' + resource.name + '\": ' + resource.url;\n\n      }\n    }\n\n    return result;\n  };\n\n  return PrepData;\n})();\n\n/*\n * Builds one or many THREE.Mesh from one raw set of Arraybuffers, materialGroup descriptions and further parameters.\n * Supports vertex, vertexColor, normal, uv and index buffers.\n * @class\n */\nLoaderSupport.MeshBuilder = (function () {\n\n  var LOADER_MESH_BUILDER_VERSION = '1.2.2';\n\n  var Validator = LoaderSupport.Validator;\n\n  function MeshBuilder() {\n    console.info( 'Using LoaderSupport.MeshBuilder version: ' + LOADER_MESH_BUILDER_VERSION );\n    this.logging = {\n      enabled: true,\n      debug: false\n    };\n\n    this.callbacks = new LoaderSupport.Callbacks();\n    this.materials = [];\n  }\n\n  /*\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   * @memberOf LoaderSupport.MeshBuilder\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   */\n  MeshBuilder.prototype.setLogging = function ( enabled, debug ) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n  };\n\n  /*\n   * Initializes the MeshBuilder (currently only default material initialisation).\n   * @memberOf LoaderSupport.MeshBuilder\n   *\n   */\n  MeshBuilder.prototype.init = function () {\n    var defaultMaterial = new THREE.MeshStandardMaterial( { color: 0xDCF1FF } );\n    defaultMaterial.name = 'defaultMaterial';\n\n    var defaultVertexColorMaterial = new THREE.MeshStandardMaterial( { color: 0xDCF1FF } );\n    defaultVertexColorMaterial.name = 'defaultVertexColorMaterial';\n    defaultVertexColorMaterial.vertexColors = THREE.VertexColors;\n\n    var defaultLineMaterial = new THREE.LineBasicMaterial();\n    defaultLineMaterial.name = 'defaultLineMaterial';\n\n    var defaultPointMaterial = new THREE.PointsMaterial( { size: 1 } );\n    defaultPointMaterial.name = 'defaultPointMaterial';\n\n    var runtimeMaterials = {};\n    runtimeMaterials[ defaultMaterial.name ] = defaultMaterial;\n    runtimeMaterials[ defaultVertexColorMaterial.name ] = defaultVertexColorMaterial;\n    runtimeMaterials[ defaultLineMaterial.name ] = defaultLineMaterial;\n    runtimeMaterials[ defaultPointMaterial.name ] = defaultPointMaterial;\n\n    this.updateMaterials(\n      {\n        cmd: 'materialData',\n        materials: {\n          materialCloneInstructions: null,\n          serializedMaterials: null,\n          runtimeMaterials: runtimeMaterials\n        }\n      }\n    );\n  };\n\n  /*\n   * Set materials loaded by any supplier of an Array of {@link THREE.Material}.\n   * @memberOf LoaderSupport.MeshBuilder\n   *\n   * @param {THREE.Material[]} materials Array of {@link THREE.Material}\n   */\n  MeshBuilder.prototype.setMaterials = function ( materials ) {\n    var payload = {\n      cmd: 'materialData',\n      materials: {\n        materialCloneInstructions: null,\n        serializedMaterials: null,\n        runtimeMaterials: Validator.isValid( this.callbacks.onLoadMaterials ) ? this.callbacks.onLoadMaterials( materials ) : materials\n      }\n    };\n    this.updateMaterials( payload );\n  };\n\n  MeshBuilder.prototype._setCallbacks = function ( callbacks ) {\n    if ( Validator.isValid( callbacks.onProgress ) ) this.callbacks.setCallbackOnProgress( callbacks.onProgress );\n    if ( Validator.isValid( callbacks.onReportError ) ) this.callbacks.setCallbackOnReportError( callbacks.onReportError );\n    if ( Validator.isValid( callbacks.onMeshAlter ) ) this.callbacks.setCallbackOnMeshAlter( callbacks.onMeshAlter );\n    if ( Validator.isValid( callbacks.onLoad ) ) this.callbacks.setCallbackOnLoad( callbacks.onLoad );\n    if ( Validator.isValid( callbacks.onLoadMaterials ) ) this.callbacks.setCallbackOnLoadMaterials( callbacks.onLoadMaterials );\n  };\n\n  /*\n   * Delegates processing of the payload (mesh building or material update) to the corresponding functions (BW-compatibility).\n   * @memberOf LoaderSupport.MeshBuilder\n   *\n   * @param {Object} payload Raw Mesh or Material descriptions.\n   * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh} or null in case of material update\n   */\n  MeshBuilder.prototype.processPayload = function ( payload ) {\n    if ( payload.cmd === 'meshData' ) {\n\n      return this.buildMeshes( payload );\n\n    } else if ( payload.cmd === 'materialData' ) {\n\n      this.updateMaterials( payload );\n      return null;\n\n    }\n  };\n\n  /*\n   * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n   * @memberOf LoaderSupport.MeshBuilder\n   *\n   * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n   * @returns {THREE.Mesh[]} mesh Array of {@link THREE.Mesh}\n   */\n  MeshBuilder.prototype.buildMeshes = function ( meshPayload ) {\n    var meshName = meshPayload.params.meshName;\n\n    var bufferGeometry = new THREE.BufferGeometry();\n    bufferGeometry.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.vertices ), 3 ) );\n    if ( Validator.isValid( meshPayload.buffers.indices ) ) {\n\n      bufferGeometry.setIndex( new THREE.BufferAttribute( new Uint32Array( meshPayload.buffers.indices ), 1 ));\n\n    }\n    var haveVertexColors = Validator.isValid( meshPayload.buffers.colors );\n    if ( haveVertexColors ) {\n\n      bufferGeometry.addAttribute( 'color', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.colors ), 3 ) );\n\n    }\n    if ( Validator.isValid( meshPayload.buffers.normals ) ) {\n\n      bufferGeometry.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.normals ), 3 ) );\n\n    } else {\n\n      bufferGeometry.computeVertexNormals();\n\n    }\n    if ( Validator.isValid( meshPayload.buffers.uvs ) ) {\n\n      bufferGeometry.addAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( meshPayload.buffers.uvs ), 2 ) );\n\n    }\n\n    var material, materialName, key;\n    var materialNames = meshPayload.materials.materialNames;\n    var createMultiMaterial = meshPayload.materials.multiMaterial;\n    var multiMaterials = [];\n    for ( key in materialNames ) {\n\n      materialName = materialNames[ key ];\n      material = this.materials[ materialName ];\n      if ( createMultiMaterial ) multiMaterials.push( material );\n\n    }\n    if ( createMultiMaterial ) {\n\n      material = multiMaterials;\n      var materialGroups = meshPayload.materials.materialGroups;\n      var materialGroup;\n      for ( key in materialGroups ) {\n\n        materialGroup = materialGroups[ key ];\n        bufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );\n\n      }\n\n    }\n\n    var meshes = [];\n    var mesh;\n    var callbackOnMeshAlter = this.callbacks.onMeshAlter;\n    var callbackOnMeshAlterResult;\n    var useOrgMesh = true;\n    var geometryType = Validator.verifyInput( meshPayload.geometryType, 0 );\n    if ( Validator.isValid( callbackOnMeshAlter ) ) {\n\n      callbackOnMeshAlterResult = callbackOnMeshAlter(\n        {\n          detail: {\n            meshName: meshName,\n            bufferGeometry: bufferGeometry,\n            material: material,\n            geometryType: geometryType\n          }\n        }\n      );\n      if ( Validator.isValid( callbackOnMeshAlterResult ) ) {\n\n        if ( callbackOnMeshAlterResult.isDisregardMesh() ) {\n\n          useOrgMesh = false;\n\n        } else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {\n\n          for ( var i in callbackOnMeshAlterResult.meshes ) {\n\n            meshes.push( callbackOnMeshAlterResult.meshes[ i ] );\n\n          }\n          useOrgMesh = false;\n\n        }\n\n      }\n\n    }\n    if ( useOrgMesh ) {\n\n      if ( meshPayload.computeBoundingSphere ) bufferGeometry.computeBoundingSphere();\n      if ( geometryType === 0 ) {\n\n        mesh = new THREE.Mesh( bufferGeometry, material );\n\n      } else if ( geometryType === 1) {\n\n        mesh = new THREE.LineSegments( bufferGeometry, material );\n\n      } else {\n\n        mesh = new THREE.Points( bufferGeometry, material );\n\n      }\n      mesh.name = meshName;\n      meshes.push( mesh );\n\n    }\n\n    var progressMessage;\n    if ( Validator.isValid( meshes ) && meshes.length > 0 ) {\n\n      var meshNames = [];\n      for ( var i in meshes ) {\n\n        mesh = meshes[ i ];\n        meshNames[ i ] = mesh.name;\n\n      }\n      progressMessage = 'Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n      progressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n    } else {\n\n      progressMessage = 'Not adding mesh: ' + meshName;\n      progressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n    }\n    var callbackOnProgress = this.callbacks.onProgress;\n    if ( Validator.isValid( callbackOnProgress ) ) {\n\n      var event = new CustomEvent( 'MeshBuilderEvent', {\n        detail: {\n          type: 'progress',\n          modelName: meshPayload.params.meshName,\n          text: progressMessage,\n          numericalValue: meshPayload.progress.numericalValue\n        }\n      } );\n      callbackOnProgress( event );\n\n    }\n\n    return meshes;\n  };\n\n  /*\n   * Updates the materials with contained material objects (sync) or from alteration instructions (async).\n   * @memberOf LoaderSupport.MeshBuilder\n   *\n   * @param {Object} materialPayload Material update instructions\n   */\n  MeshBuilder.prototype.updateMaterials = function ( materialPayload ) {\n    var material, materialName;\n    var materialCloneInstructions = materialPayload.materials.materialCloneInstructions;\n    if ( Validator.isValid( materialCloneInstructions ) ) {\n\n      var materialNameOrg = materialCloneInstructions.materialNameOrg;\n      var materialOrg = this.materials[ materialNameOrg ];\n\n      if ( Validator.isValid( materialNameOrg ) ) {\n\n        material = materialOrg.clone();\n\n        materialName = materialCloneInstructions.materialName;\n        material.name = materialName;\n\n        var materialProperties = materialCloneInstructions.materialProperties;\n        for ( var key in materialProperties ) {\n\n          if ( material.hasOwnProperty( key ) && materialProperties.hasOwnProperty( key ) ) material[ key ] = materialProperties[ key ];\n\n        }\n        this.materials[ materialName ] = material;\n\n      } else {\n\n        console.warn( 'Requested material \"' + materialNameOrg + '\" is not available!' );\n\n      }\n    }\n\n    var materials = materialPayload.materials.serializedMaterials;\n    if ( Validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {\n\n      var loader = new THREE.MaterialLoader();\n      var materialJson;\n      for ( materialName in materials ) {\n\n        materialJson = materials[ materialName ];\n        if ( Validator.isValid( materialJson ) ) {\n\n          material = loader.parse( materialJson );\n          if ( this.logging.enabled ) console.info( 'De-serialized material with name \"' + materialName + '\" will be added.' );\n          this.materials[ materialName ] = material;\n        }\n\n      }\n\n    }\n\n    materials = materialPayload.materials.runtimeMaterials;\n    if ( Validator.isValid( materials ) && Object.keys( materials ).length > 0 ) {\n\n      for ( materialName in materials ) {\n\n        material = materials[ materialName ];\n        if ( this.logging.enabled ) console.info( 'Material with name \"' + materialName + '\" will be added.' );\n        this.materials[ materialName ] = material;\n\n      }\n\n    }\n  };\n\n  /*\n   * Returns the mapping object of material name and corresponding jsonified material.\n   *\n   * @returns {Object} Map of Materials in JSON representation\n   */\n  MeshBuilder.prototype.getMaterialsJSON = function () {\n    var materialsJSON = {};\n    var material;\n    for ( var materialName in this.materials ) {\n\n      material = this.materials[ materialName ];\n      materialsJSON[ materialName ] = material.toJSON();\n    }\n\n    return materialsJSON;\n  };\n\n  /*\n   * Returns the mapping object of material name and corresponding material.\n   *\n   * @returns {Object} Map of {@link THREE.Material}\n   */\n  MeshBuilder.prototype.getMaterials = function () {\n    return this.materials;\n  };\n\n  return MeshBuilder;\n})();\n\n/*\n * Default implementation of the WorkerRunner responsible for creation and configuration of the parser within the worker.\n *\n * @class\n */\nLoaderSupport.WorkerRunnerRefImpl = (function () {\n\n  function WorkerRunnerRefImpl() {\n    var scope = this;\n    var scopedRunner = function( event ) {\n      scope.processMessage( event.data );\n    };\n    self.addEventListener( 'message', scopedRunner, false );\n  }\n\n  /*\n   * Applies values from parameter object via set functions or via direct assignment.\n   * @memberOf LoaderSupport.WorkerRunnerRefImpl\n   *\n   * @param {Object} parser The parser instance\n   * @param {Object} params The parameter object\n   */\n  WorkerRunnerRefImpl.prototype.applyProperties = function ( parser, params ) {\n    var property, funcName, values;\n    for ( property in params ) {\n      funcName = 'set' + property.substring( 0, 1 ).toLocaleUpperCase() + property.substring( 1 );\n      values = params[ property ];\n\n      if ( typeof parser[ funcName ] === 'function' ) {\n\n        parser[ funcName ]( values );\n\n      } else if ( parser.hasOwnProperty( property ) ) {\n\n        parser[ property ] = values;\n\n      }\n    }\n  };\n\n  /*\n   * Configures the Parser implementation according the supplied configuration object.\n   * @memberOf LoaderSupport.WorkerRunnerRefImpl\n   *\n   * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n   */\n  WorkerRunnerRefImpl.prototype.processMessage = function ( payload ) {\n    if ( payload.cmd === 'run' ) {\n\n      var callbacks = {\n        callbackMeshBuilder: function ( payload ) {\n          self.postMessage( payload );\n        },\n        callbackProgress: function ( text ) {\n          if ( payload.logging.enabled && payload.logging.debug ) console.debug( 'WorkerRunner: progress: ' + text );\n        }\n      };\n\n      // Parser is expected to be named as such\n      var parser = new Parser();\n      if ( typeof parser[ 'setLogging' ] === 'function' ) parser.setLogging( payload.logging.enabled, payload.logging.debug );\n      this.applyProperties( parser, payload.params );\n      this.applyProperties( parser, payload.materials );\n      this.applyProperties( parser, callbacks );\n      parser.workerScope = self;\n      parser.parse( payload.data.input, payload.data.options );\n\n      if ( payload.logging.enabled ) console.log( 'WorkerRunner: Run complete!' );\n\n      callbacks.callbackMeshBuilder( {\n        cmd: 'complete',\n        msg: 'WorkerRunner completed run.'\n      } );\n\n    } else {\n\n      console.error( 'WorkerRunner: Received unknown command: ' + payload.cmd );\n\n    }\n  };\n\n  return WorkerRunnerRefImpl;\n})();\n\n/*\n * This class provides means to transform existing parser code into a web worker. It defines a simple communication protocol\n * which allows to configure the worker and receive raw mesh data during execution.\n * @class\n */\nLoaderSupport.WorkerSupport = (function () {\n\n  var WORKER_SUPPORT_VERSION = '2.2.1';\n\n  var Validator = LoaderSupport.Validator;\n\n  var LoaderWorker = (function () {\n\n    function LoaderWorker() {\n      this._reset();\n    }\n\n    LoaderWorker.prototype._reset = function () {\n      this.logging = {\n        enabled: true,\n        debug: false\n      };\n      this.worker = null;\n      this.runnerImplName = null;\n      this.callbacks = {\n        meshBuilder: null,\n        onLoad: null\n      };\n      this.terminateRequested = false;\n      this.queuedMessage = null;\n      this.started = false;\n      this.forceCopy = false;\n    };\n\n    LoaderWorker.prototype.setLogging = function ( enabled, debug ) {\n      this.logging.enabled = enabled === true;\n      this.logging.debug = debug === true;\n    };\n\n    LoaderWorker.prototype.setForceCopy = function ( forceCopy ) {\n      this.forceCopy = forceCopy === true;\n    };\n\n    LoaderWorker.prototype.initWorker = function ( code, runnerImplName ) {\n      this.runnerImplName = runnerImplName;\n      var blob = new Blob( [ code ], { type: 'application/javascript' } );\n      this.worker = new Worker( window.URL.createObjectURL( blob ) );\n      this.worker.onmessage = this._receiveWorkerMessage;\n\n      // set referemce to this, then processing in worker scope within \"_receiveWorkerMessage\" can access members\n      this.worker.runtimeRef = this;\n\n      // process stored queuedMessage\n      this._postMessage();\n    };\n\n    /*\n     * Executed in worker scope\n      */\n    LoaderWorker.prototype._receiveWorkerMessage = function ( e ) {\n      var payload = e.data;\n      switch ( payload.cmd ) {\n        case 'meshData':\n        case 'materialData':\n        case 'imageData':\n          this.runtimeRef.callbacks.meshBuilder( payload );\n          break;\n\n        case 'complete':\n          this.runtimeRef.queuedMessage = null;\n          this.started = false;\n          this.runtimeRef.callbacks.onLoad( payload.msg );\n\n          if ( this.runtimeRef.terminateRequested ) {\n\n            if ( this.runtimeRef.logging.enabled ) console.info( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run is complete. Terminating application on request!' );\n            this.runtimeRef._terminate();\n\n          }\n          break;\n\n        case 'error':\n          console.error( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Reported error: ' + payload.msg );\n          this.runtimeRef.queuedMessage = null;\n          this.started = false;\n          this.runtimeRef.callbacks.onLoad( payload.msg );\n\n          if ( this.runtimeRef.terminateRequested ) {\n\n            if ( this.runtimeRef.logging.enabled ) console.info( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Run reported error. Terminating application on request!' );\n            this.runtimeRef._terminate();\n\n          }\n          break;\n\n        default:\n          console.error( 'WorkerSupport [' + this.runtimeRef.runnerImplName + ']: Received unknown command: ' + payload.cmd );\n          break;\n\n      }\n    };\n\n    LoaderWorker.prototype.setCallbacks = function ( meshBuilder, onLoad ) {\n      this.callbacks.meshBuilder = Validator.verifyInput( meshBuilder, this.callbacks.meshBuilder );\n      this.callbacks.onLoad = Validator.verifyInput( onLoad, this.callbacks.onLoad );\n    };\n\n    LoaderWorker.prototype.run = function( payload ) {\n      if ( Validator.isValid( this.queuedMessage ) ) {\n\n        console.warn( 'Already processing message. Rejecting new run instruction' );\n        return;\n\n      } else {\n\n        this.queuedMessage = payload;\n        this.started = true;\n\n      }\n      if ( ! Validator.isValid( this.callbacks.meshBuilder ) ) throw 'Unable to run as no \"MeshBuilder\" callback is set.';\n      if ( ! Validator.isValid( this.callbacks.onLoad ) ) throw 'Unable to run as no \"onLoad\" callback is set.';\n      if ( payload.cmd !== 'run' ) payload.cmd = 'run';\n      if ( Validator.isValid( payload.logging ) ) {\n\n        payload.logging.enabled = payload.logging.enabled === true;\n        payload.logging.debug = payload.logging.debug === true;\n\n      } else {\n\n        payload.logging = {\n          enabled: true,\n          debug: false\n        };\n\n      }\n      this._postMessage();\n    };\n\n    LoaderWorker.prototype._postMessage = function () {\n      if ( Validator.isValid( this.queuedMessage ) && Validator.isValid( this.worker ) ) {\n\n        if ( this.queuedMessage.data.input instanceof ArrayBuffer ) {\n\n          var content;\n          if ( this.forceCopy ) {\n\n            content = this.queuedMessage.data.input.slice( 0 );\n\n          } else {\n\n            content = this.queuedMessage.data.input;\n\n          }\n          this.worker.postMessage( this.queuedMessage, [ content ] );\n\n        } else {\n\n          this.worker.postMessage( this.queuedMessage );\n\n        }\n\n      }\n    };\n\n    LoaderWorker.prototype.setTerminateRequested = function ( terminateRequested ) {\n      this.terminateRequested = terminateRequested === true;\n      if ( this.terminateRequested && Validator.isValid( this.worker ) && ! Validator.isValid( this.queuedMessage ) && this.started ) {\n\n        if ( this.logging.enabled ) console.info( 'Worker is terminated immediately as it is not running!' );\n        this._terminate();\n\n      }\n    };\n\n    LoaderWorker.prototype._terminate = function () {\n      this.worker.terminate();\n      this._reset();\n    };\n\n    return LoaderWorker;\n\n  })();\n\n  function WorkerSupport() {\n    console.info( 'Using LoaderSupport.WorkerSupport version: ' + WORKER_SUPPORT_VERSION );\n    this.logging = {\n      enabled: true,\n      debug: false\n    };\n\n    // check worker support first\n    if ( window.Worker === undefined ) throw \"This browser does not support web workers!\";\n    if ( window.Blob === undefined  ) throw \"This browser does not support Blob!\";\n    if ( typeof window.URL.createObjectURL !== 'function'  ) throw \"This browser does not support Object creation from URL!\";\n\n    this.loaderWorker = new LoaderWorker();\n  }\n\n  /*\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   * @memberOf LoaderSupport.WorkerSupport\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   */\n  WorkerSupport.prototype.setLogging = function ( enabled, debug ) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n    this.loaderWorker.setLogging( this.logging.enabled, this.logging.debug );\n  };\n\n  /*\n   * Forces all ArrayBuffers to be transferred to worker to be copied.\n   * @memberOf LoaderSupport.WorkerSupport\n   *\n   * @param {boolean} forceWorkerDataCopy True or false.\n   */\n  WorkerSupport.prototype.setForceWorkerDataCopy = function ( forceWorkerDataCopy ) {\n    this.loaderWorker.setForceCopy( forceWorkerDataCopy );\n  };\n\n  /*\n   * Validate the status of worker code and the derived worker.\n   * @memberOf LoaderSupport.WorkerSupport\n   *\n   * @param {Function} functionCodeBuilder Function that is invoked with funcBuildObject and funcBuildSingleton that allows stringification of objects and singletons.\n   * @param {String} parserName Name of the Parser object\n   * @param {String[]} libLocations URL of libraries that shall be added to worker code relative to libPath\n   * @param {String} libPath Base path used for loading libraries\n   * @param {LoaderSupport.WorkerRunnerRefImpl} runnerImpl The default worker parser wrapper implementation (communication and execution). An extended class could be passed here.\n   */\n  WorkerSupport.prototype.validate = function ( functionCodeBuilder, parserName, libLocations, libPath, runnerImpl ) {\n    if ( Validator.isValid( this.loaderWorker.worker ) ) return;\n\n    if ( this.logging.enabled ) {\n\n      console.info( 'WorkerSupport: Building worker code...' );\n      console.time( 'buildWebWorkerCode' );\n\n    }\n    if ( Validator.isValid( runnerImpl ) ) {\n\n      if ( this.logging.enabled ) console.info( 'WorkerSupport: Using \"' + runnerImpl.name + '\" as Runner class for worker.' );\n\n    } else {\n\n      runnerImpl = LoaderSupport.WorkerRunnerRefImpl;\n      if ( this.logging.enabled ) console.info( 'WorkerSupport: Using DEFAULT \"LoaderSupport.WorkerRunnerRefImpl\" as Runner class for worker.' );\n\n    }\n\n    var userWorkerCode = functionCodeBuilder( buildObject, buildSingleton );\n    userWorkerCode += 'var Parser = '+ parserName +  ';\\n\\n';\n    userWorkerCode += buildSingleton( runnerImpl.name, runnerImpl );\n    userWorkerCode += 'new ' + runnerImpl.name + '();\\n\\n';\n\n    var scope = this;\n    if ( Validator.isValid( libLocations ) && libLocations.length > 0 ) {\n\n      var libsContent = '';\n      var loadAllLibraries = function ( path, locations ) {\n        if ( locations.length === 0 ) {\n\n          scope.loaderWorker.initWorker( libsContent + userWorkerCode, runnerImpl.name );\n          if ( scope.logging.enabled ) console.timeEnd( 'buildWebWorkerCode' );\n\n        } else {\n\n          var loadedLib = function ( contentAsString ) {\n            libsContent += contentAsString;\n            loadAllLibraries( path, locations );\n          };\n\n          var fileLoader = new THREE.FileLoader();\n          fileLoader.setPath( path );\n          fileLoader.setResponseType( 'text' );\n          fileLoader.load( locations[ 0 ], loadedLib );\n          locations.shift();\n\n        }\n      };\n      loadAllLibraries( libPath, libLocations );\n\n    } else {\n\n      this.loaderWorker.initWorker( userWorkerCode, runnerImpl.name );\n      if ( this.logging.enabled ) console.timeEnd( 'buildWebWorkerCode' );\n\n    }\n  };\n\n  /*\n   * Specify functions that should be build when new raw mesh data becomes available and when the parser is finished.\n   * @memberOf LoaderSupport.WorkerSupport\n   *\n   * @param {Function} meshBuilder The mesh builder function. Default is {@link LoaderSupport.MeshBuilder}.\n   * @param {Function} onLoad The function that is called when parsing is complete.\n   */\n  WorkerSupport.prototype.setCallbacks = function ( meshBuilder, onLoad ) {\n    this.loaderWorker.setCallbacks( meshBuilder, onLoad );\n  };\n\n  /*\n   * Runs the parser with the provided configuration.\n   * @memberOf LoaderSupport.WorkerSupport\n   *\n   * @param {Object} payload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n   */\n  WorkerSupport.prototype.run = function ( payload ) {\n    this.loaderWorker.run( payload );\n  };\n\n  /*\n   * Request termination of worker once parser is finished.\n   * @memberOf LoaderSupport.WorkerSupport\n   *\n   * @param {boolean} terminateRequested True or false.\n   */\n  WorkerSupport.prototype.setTerminateRequested = function ( terminateRequested ) {\n    this.loaderWorker.setTerminateRequested( terminateRequested );\n  };\n\n  var buildObject = function ( fullName, object ) {\n    var objectString = fullName + ' = {\\n';\n    var part;\n    for ( var name in object ) {\n\n      part = object[ name ];\n      if ( typeof( part ) === 'string' || part instanceof String ) {\n\n        part = part.replace( '\\n', '\\\\n' );\n        part = part.replace( '\\r', '\\\\r' );\n        objectString += '\\t' + name + ': \"' + part + '\",\\n';\n\n      } else if ( part instanceof Array ) {\n\n        objectString += '\\t' + name + ': [' + part + '],\\n';\n\n      } else if ( Number.isInteger( part ) ) {\n\n        objectString += '\\t' + name + ': ' + part + ',\\n';\n\n      } else if ( typeof part === 'function' ) {\n\n        objectString += '\\t' + name + ': ' + part + ',\\n';\n\n      }\n\n    }\n    objectString += '}\\n\\n';\n\n    return objectString;\n  };\n\n  var buildSingleton = function ( fullName, object, internalName, basePrototypeName, ignoreFunctions ) {\n    var objectString = '';\n    var objectName = ( Validator.isValid( internalName ) ) ? internalName : object.name;\n\n    var funcString, objectPart, constructorString;\n    ignoreFunctions = Validator.verifyInput( ignoreFunctions, [] );\n    for ( var name in object.prototype ) {\n\n      objectPart = object.prototype[ name ];\n      if ( name === 'constructor' ) {\n\n        funcString = objectPart.toString();\n        funcString = funcString.replace( 'function', '' );\n        constructorString = '\\tfunction ' + objectName + funcString + ';\\n\\n';\n\n      } else if ( typeof objectPart === 'function' ) {\n\n        if ( ignoreFunctions.indexOf( name ) < 0 ) {\n\n          funcString = objectPart.toString();\n          objectString += '\\t' + objectName + '.prototype.' + name + ' = ' + funcString + ';\\n\\n';\n\n        }\n\n      }\n\n    }\n    objectString += '\\treturn ' + objectName + ';\\n';\n    objectString += '})();\\n\\n';\n\n    var inheritanceBlock = '';\n    if ( Validator.isValid( basePrototypeName ) ) {\n\n      inheritanceBlock += '\\n';\n      inheritanceBlock += objectName + '.prototype = Object.create( ' + basePrototypeName + '.prototype );\\n';\n      inheritanceBlock += objectName + '.constructor = ' + objectName + ';\\n';\n      inheritanceBlock += '\\n';\n    }\n    if ( ! Validator.isValid( constructorString ) ) {\n\n      constructorString = fullName + ' = (function () {\\n\\n';\n      constructorString += inheritanceBlock + '\\t' + object.prototype.constructor.toString() + '\\n\\n';\n      objectString = constructorString + objectString;\n\n    } else {\n\n      objectString = fullName + ' = (function () {\\n\\n' + inheritanceBlock + constructorString + objectString;\n\n    }\n\n    return objectString;\n  };\n\n  return WorkerSupport;\n\n})();\n\n/*\n * Orchestrate loading of multiple OBJ files/data from an instruction queue with a configurable amount of workers (1-16).\n * Workflow:\n *   prepareWorkers\n *   enqueueForRun\n *   processQueue\n *   tearDown (to force stop)\n *\n * @class\n *\n * @param {string} classDef Class definition to be used for construction\n */\nLoaderSupport.WorkerDirector = (function () {\n\n  var LOADER_WORKER_DIRECTOR_VERSION = '2.2.2';\n\n  var Validator = LoaderSupport.Validator;\n\n  var MAX_WEB_WORKER = 16;\n  var MAX_QUEUE_SIZE = 8192;\n\n  function WorkerDirector( classDef ) {\n    console.info( 'Using LoaderSupport.WorkerDirector version: ' + LOADER_WORKER_DIRECTOR_VERSION );\n    this.logging = {\n      enabled: true,\n      debug: false\n    };\n\n    this.maxQueueSize = MAX_QUEUE_SIZE ;\n    this.maxWebWorkers = MAX_WEB_WORKER;\n    this.crossOrigin = null;\n\n    if ( ! Validator.isValid( classDef ) ) throw 'Provided invalid classDef: ' + classDef;\n\n    this.workerDescription = {\n      classDef: classDef,\n      globalCallbacks: {},\n      workerSupports: {},\n      forceWorkerDataCopy: true\n    };\n    this.objectsCompleted = 0;\n    this.instructionQueue = [];\n    this.instructionQueuePointer = 0;\n\n    this.callbackOnFinishedProcessing = null;\n  }\n\n  /*\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   */\n  WorkerDirector.prototype.setLogging = function ( enabled, debug ) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n  };\n\n  /*\n   * Returns the maximum length of the instruction queue.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @returns {number}\n   */\n  WorkerDirector.prototype.getMaxQueueSize = function () {\n    return this.maxQueueSize;\n  };\n\n  /*\n   * Returns the maximum number of workers.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @returns {number}\n   */\n  WorkerDirector.prototype.getMaxWebWorkers = function () {\n    return this.maxWebWorkers;\n  };\n\n  /*\n   * Sets the CORS string to be used.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @param {string} crossOrigin CORS value\n   */\n  WorkerDirector.prototype.setCrossOrigin = function ( crossOrigin ) {\n    this.crossOrigin = crossOrigin;\n  };\n\n  /*\n   * Forces all ArrayBuffers to be transferred to worker to be copied.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @param {boolean} forceWorkerDataCopy True or false.\n   */\n  WorkerDirector.prototype.setForceWorkerDataCopy = function ( forceWorkerDataCopy ) {\n    this.workerDescription.forceWorkerDataCopy = forceWorkerDataCopy === true;\n  };\n\n  /*\n   * Create or destroy workers according limits. Set the name and register callbacks for dynamically created web workers.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @param {THREE.OBJLoader2.WWOBJLoader2.PrepDataCallbacks} globalCallbacks  Register global callbacks used by all web workers\n   * @param {number} maxQueueSize Set the maximum size of the instruction queue (1-1024)\n   * @param {number} maxWebWorkers Set the maximum amount of workers (1-16)\n   */\n  WorkerDirector.prototype.prepareWorkers = function ( globalCallbacks, maxQueueSize, maxWebWorkers ) {\n    if ( Validator.isValid( globalCallbacks ) ) this.workerDescription.globalCallbacks = globalCallbacks;\n    this.maxQueueSize = Math.min( maxQueueSize, MAX_QUEUE_SIZE );\n    this.maxWebWorkers = Math.min( maxWebWorkers, MAX_WEB_WORKER );\n    this.maxWebWorkers = Math.min( this.maxWebWorkers, this.maxQueueSize );\n    this.objectsCompleted = 0;\n    this.instructionQueue = [];\n    this.instructionQueuePointer = 0;\n\n    for ( var instanceNo = 0; instanceNo < this.maxWebWorkers; instanceNo++ ) {\n\n      var workerSupport = new LoaderSupport.WorkerSupport();\n      workerSupport.setLogging( this.logging.enabled, this.logging.debug );\n      workerSupport.setForceWorkerDataCopy( this.workerDescription.forceWorkerDataCopy );\n      this.workerDescription.workerSupports[ instanceNo ] = {\n        instanceNo: instanceNo,\n        inUse: false,\n        terminateRequested: false,\n        workerSupport: workerSupport,\n        loader: null\n      };\n\n    }\n  };\n\n  /*\n   * Store run instructions in internal instructionQueue.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @param {LoaderSupport.PrepData} prepData\n   */\n  WorkerDirector.prototype.enqueueForRun = function ( prepData ) {\n    if ( this.instructionQueue.length < this.maxQueueSize ) {\n      this.instructionQueue.push( prepData );\n    }\n  };\n\n  /*\n   * Returns if any workers are running.\n   *\n   * @memberOf LoaderSupport.WorkerDirector\n   * @returns {boolean}\n   */\n  WorkerDirector.prototype.isRunning = function () {\n    var wsKeys = Object.keys( this.workerDescription.workerSupports );\n    return ( ( this.instructionQueue.length > 0 && this.instructionQueuePointer < this.instructionQueue.length ) || wsKeys.length > 0 );\n  };\n\n  /*\n   * Process the instructionQueue until it is depleted.\n   * @memberOf LoaderSupport.WorkerDirector\n   */\n  WorkerDirector.prototype.processQueue = function () {\n    var prepData, supportDesc;\n    for ( var instanceNo in this.workerDescription.workerSupports ) {\n\n      supportDesc = this.workerDescription.workerSupports[ instanceNo ];\n      if ( ! supportDesc.inUse ) {\n\n        if ( this.instructionQueuePointer < this.instructionQueue.length ) {\n\n          prepData = this.instructionQueue[ this.instructionQueuePointer ];\n          this._kickWorkerRun( prepData, supportDesc );\n          this.instructionQueuePointer++;\n\n        } else {\n\n          this._deregister( supportDesc );\n\n        }\n\n      }\n\n    }\n\n    if ( ! this.isRunning() && this.callbackOnFinishedProcessing !== null ) {\n\n      this.callbackOnFinishedProcessing();\n      this.callbackOnFinishedProcessing = null;\n\n    }\n  };\n\n  WorkerDirector.prototype._kickWorkerRun = function( prepData, supportDesc ) {\n    supportDesc.inUse = true;\n    supportDesc.workerSupport.setTerminateRequested( supportDesc.terminateRequested );\n\n    if ( this.logging.enabled ) console.info( '\\nAssigning next item from queue to worker (queue length: ' + this.instructionQueue.length + ')\\n\\n' );\n\n    var scope = this;\n    var prepDataCallbacks = prepData.getCallbacks();\n    var globalCallbacks = this.workerDescription.globalCallbacks;\n    var wrapperOnLoad = function ( event ) {\n      if ( Validator.isValid( globalCallbacks.onLoad ) ) globalCallbacks.onLoad( event );\n      if ( Validator.isValid( prepDataCallbacks.onLoad ) ) prepDataCallbacks.onLoad( event );\n      scope.objectsCompleted++;\n      supportDesc.inUse = false;\n\n      scope.processQueue();\n    };\n\n    var wrapperOnProgress = function ( event ) {\n      if ( Validator.isValid( globalCallbacks.onProgress ) ) globalCallbacks.onProgress( event );\n      if ( Validator.isValid( prepDataCallbacks.onProgress ) ) prepDataCallbacks.onProgress( event );\n    };\n\n    var wrapperOnMeshAlter = function ( event, override ) {\n      if ( Validator.isValid( globalCallbacks.onMeshAlter ) ) override = globalCallbacks.onMeshAlter( event, override );\n      if ( Validator.isValid( prepDataCallbacks.onMeshAlter ) ) override = globalCallbacks.onMeshAlter( event, override );\n      return override;\n    };\n\n    var wrapperOnLoadMaterials = function ( materials ) {\n      if ( Validator.isValid( globalCallbacks.onLoadMaterials ) ) materials = globalCallbacks.onLoadMaterials( materials );\n      if ( Validator.isValid( prepDataCallbacks.onLoadMaterials ) ) materials = prepDataCallbacks.onLoadMaterials( materials );\n      return materials;\n    };\n\n    var wrapperOnReportError = function ( errorMessage ) {\n      var continueProcessing = true;\n      if ( Validator.isValid( globalCallbacks.onReportError ) ) continueProcessing = globalCallbacks.onReportError( supportDesc, errorMessage );\n      if ( Validator.isValid( prepDataCallbacks.onReportError ) )  continueProcessing = prepDataCallbacks.onReportError( supportDesc, errorMessage );\n\n      if ( ! Validator.isValid( globalCallbacks.onReportError ) && ! Validator.isValid( prepDataCallbacks.onReportError ) ) {\n\n        console.error( 'Loader reported an error: ' );\n        console.error( errorMessage );\n\n      }\n      if ( continueProcessing ) {\n\n        supportDesc.inUse = false;\n        scope.processQueue();\n\n      }\n    };\n\n    supportDesc.loader = this._buildLoader( supportDesc.instanceNo );\n\n    var updatedCallbacks = new LoaderSupport.Callbacks();\n    updatedCallbacks.setCallbackOnLoad( wrapperOnLoad );\n    updatedCallbacks.setCallbackOnProgress( wrapperOnProgress );\n    updatedCallbacks.setCallbackOnReportError( wrapperOnReportError );\n    updatedCallbacks.setCallbackOnMeshAlter( wrapperOnMeshAlter );\n    updatedCallbacks.setCallbackOnLoadMaterials( wrapperOnLoadMaterials );\n    prepData.callbacks = updatedCallbacks;\n\n    supportDesc.loader.run( prepData, supportDesc.workerSupport );\n  };\n\n  WorkerDirector.prototype._buildLoader = function ( instanceNo ) {\n    var classDef = this.workerDescription.classDef;\n    var loader = Object.create( classDef.prototype );\n    classDef.call( loader, THREE.DefaultLoadingManager );\n\n    // verify that all required functions are implemented\n    if ( ! loader.hasOwnProperty( 'instanceNo' ) ) throw classDef.name + ' has no property \"instanceNo\".';\n    loader.instanceNo = instanceNo;\n\n    if ( ! loader.hasOwnProperty( 'workerSupport' ) ) {\n\n      throw classDef.name + ' has no property \"workerSupport\".';\n\n    }\n    if ( typeof loader.run !== 'function'  ) throw classDef.name + ' has no function \"run\".';\n    if ( ! loader.hasOwnProperty( 'callbacks' ) || ! Validator.isValid( loader.callbacks ) ) {\n\n      console.warn( classDef.name + ' has an invalid property \"callbacks\". Will change to \"LoaderSupport.Callbacks\"' );\n      loader.callbacks = new LoaderSupport.Callbacks();\n\n    }\n\n    return loader;\n  };\n\n  WorkerDirector.prototype._deregister = function ( supportDesc ) {\n    if ( Validator.isValid( supportDesc ) ) {\n\n      supportDesc.workerSupport.setTerminateRequested( true );\n      if ( this.logging.enabled ) console.info( 'Requested termination of worker #' + supportDesc.instanceNo + '.' );\n\n      var loaderCallbacks = supportDesc.loader.callbacks;\n      if ( Validator.isValid( loaderCallbacks.onProgress ) ) loaderCallbacks.onProgress( { detail: { text: '' } } );\n      delete this.workerDescription.workerSupports[ supportDesc.instanceNo ];\n\n    }\n  };\n\n  /*\n   * Terminate all workers.\n   * @memberOf LoaderSupport.WorkerDirector\n   *\n   * @param {callback} callbackOnFinishedProcessing Function called once all workers finished processing.\n   */\n  WorkerDirector.prototype.tearDown = function ( callbackOnFinishedProcessing ) {\n    if ( this.logging.enabled ) console.info( 'WorkerDirector received the deregister call. Terminating all workers!' );\n\n    this.instructionQueuePointer = this.instructionQueue.length;\n    this.callbackOnFinishedProcessing = Validator.verifyInput( callbackOnFinishedProcessing, null );\n\n    for ( var name in this.workerDescription.workerSupports ) {\n\n      this.workerDescription.workerSupports[ name ].terminateRequested = true;\n\n    }\n  };\n\n  return WorkerDirector;\n\n})();\n\n\nexport default LoaderSupport\n","/*\n  * @author Kai Salmen / https://kaisalmen.de\n  * Development repository: https://github.com/kaisalmen/WWOBJLoader\n  */\n\nimport * as THREE from 'three'\nimport LoaderSupport from './LoaderSupport'\n\n/*\n * Use this class to load OBJ data from files or to parse OBJ data from an arraybuffer\n * @class\n *\n * @param {THREE.DefaultLoadingManager} [manager] The loadingManager for the loader to use. Default is {@link THREE.DefaultLoadingManager}\n */\nconst OBJLoader2 = (function () {\n\n  var OBJLOADER2_VERSION = '2.4.2';\n  var Validator = LoaderSupport.Validator;\n\n  function OBJLoader2( manager ) {\n    console.info( 'Using THREE.OBJLoader2 version: ' + OBJLOADER2_VERSION );\n\n    this.manager = Validator.verifyInput( manager, THREE.DefaultLoadingManager );\n    this.logging = {\n      enabled: true,\n      debug: false\n    };\n\n    this.modelName = '';\n    this.instanceNo = 0;\n    this.path = '';\n    this.useIndices = false;\n    this.disregardNormals = false;\n    this.materialPerSmoothingGroup = false;\n    this.useOAsMesh = false;\n    this.loaderRootNode = new THREE.Group();\n\n    this.meshBuilder = new LoaderSupport.MeshBuilder();\n    this.callbacks = new LoaderSupport.Callbacks();\n    this.workerSupport = new LoaderSupport.WorkerSupport();\n    this.terminateWorkerOnLoad = true;\n  }\n\n  /*\n   * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {boolean} enabled True or false.\n   * @param {boolean} debug True or false.\n   */\n  OBJLoader2.prototype.setLogging = function ( enabled, debug ) {\n    this.logging.enabled = enabled === true;\n    this.logging.debug = debug === true;\n    this.meshBuilder.setLogging( this.logging.enabled, this.logging.debug );\n  };\n\n  /*\n   * Set the name of the model.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {string} modelName\n   */\n  OBJLoader2.prototype.setModelName = function ( modelName ) {\n    this.modelName = Validator.verifyInput( modelName, this.modelName );\n  };\n\n  /*\n   * The URL of the base path.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {string} path URL\n   */\n  OBJLoader2.prototype.setPath = function ( path ) {\n    this.path = Validator.verifyInput( path, this.path );\n  };\n\n  /*\n   * Set the node where the loaded objects will be attached directly.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {THREE.Object3D} streamMeshesTo Object already attached to scenegraph where new meshes will be attached to\n   */\n  OBJLoader2.prototype.setStreamMeshesTo = function ( streamMeshesTo ) {\n    this.loaderRootNode = Validator.verifyInput( streamMeshesTo, this.loaderRootNode );\n  };\n\n  /*\n   * Set materials loaded by MTLLoader or any other supplier of an Array of {@link THREE.Material}.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {THREE.Material[]} materials Array of {@link THREE.Material}\n   */\n  OBJLoader2.prototype.setMaterials = function ( materials ) {\n    this.meshBuilder.setMaterials( materials );\n  };\n\n  /*\n   * Instructs loaders to create indexed {@link THREE.BufferGeometry}.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {boolean} useIndices=false\n   */\n  OBJLoader2.prototype.setUseIndices = function ( useIndices ) {\n    this.useIndices = useIndices === true;\n  };\n\n  /*\n   * Tells whether normals should be completely disregarded and regenerated.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {boolean} disregardNormals=false\n   */\n  OBJLoader2.prototype.setDisregardNormals = function ( disregardNormals ) {\n    this.disregardNormals = disregardNormals === true;\n  };\n\n  /*\n   * Tells whether a material shall be created per smoothing group.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {boolean} materialPerSmoothingGroup=false\n   */\n  OBJLoader2.prototype.setMaterialPerSmoothingGroup = function ( materialPerSmoothingGroup ) {\n    this.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n  };\n\n  /*\n   * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of \"o\" can be enforced.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {boolean} useOAsMesh=false\n   */\n  OBJLoader2.prototype.setUseOAsMesh = function ( useOAsMesh ) {\n    this.useOAsMesh = useOAsMesh === true;\n  };\n\n  OBJLoader2.prototype._setCallbacks = function ( callbacks ) {\n    if ( Validator.isValid( callbacks.onProgress ) ) this.callbacks.setCallbackOnProgress( callbacks.onProgress );\n    if ( Validator.isValid( callbacks.onReportError ) ) this.callbacks.setCallbackOnReportError( callbacks.onReportError );\n    if ( Validator.isValid( callbacks.onMeshAlter ) ) this.callbacks.setCallbackOnMeshAlter( callbacks.onMeshAlter );\n    if ( Validator.isValid( callbacks.onLoad ) ) this.callbacks.setCallbackOnLoad( callbacks.onLoad );\n    if ( Validator.isValid( callbacks.onLoadMaterials ) ) this.callbacks.setCallbackOnLoadMaterials( callbacks.onLoadMaterials );\n\n    this.meshBuilder._setCallbacks( this.callbacks );\n  };\n\n  /*\n   * Announce feedback which is give to the registered callbacks.\n   * @memberOf THREE.OBJLoader2\n   * @private\n   *\n   * @param {string} type The type of event\n   * @param {string} text Textual description of the event\n   * @param {number} numericalValue Numerical value describing the progress\n   */\n  OBJLoader2.prototype.onProgress = function ( type, text, numericalValue ) {\n    var content = Validator.isValid( text ) ? text: '';\n    var event = {\n      detail: {\n        type: type,\n        modelName: this.modelName,\n        instanceNo: this.instanceNo,\n        text: content,\n        numericalValue: numericalValue\n      }\n    };\n\n    if ( Validator.isValid( this.callbacks.onProgress ) ) this.callbacks.onProgress( event );\n\n    if ( this.logging.enabled && this.logging.debug ) console.debug( content );\n  };\n\n  OBJLoader2.prototype._onError = function ( event ) {\n    var output = 'Error occurred while downloading!';\n\n    if ( event.currentTarget && event.currentTarget.statusText !== null ) {\n\n      output += '\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\n\n    }\n    this.onProgress( 'error', output, -1 );\n    this._throwError( output );\n  };\n\n  OBJLoader2.prototype._throwError = function ( errorMessage ) {\n    if ( Validator.isValid( this.callbacks.onReportError ) )  {\n\n      this.callbacks.onReportError( errorMessage );\n\n    } else {\n\n      throw errorMessage;\n\n    }\n  };\n\n  /*\n   * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {string}  url A string containing the path/URL of the file to be loaded.\n   * @param {callback} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.\n   * @param {callback} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n   * @param {callback} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n   * @param {callback} [onMeshAlter] A function to be called after a new mesh raw data becomes available for alteration.\n   * @param {boolean} [useAsync] If true, uses async loading with worker, if false loads data synchronously.\n   */\n  OBJLoader2.prototype.load = function ( url, onLoad, onProgress, onError, onMeshAlter, useAsync ) {\n    var resource = new LoaderSupport.ResourceDescriptor( url, 'OBJ' );\n    this._loadObj( resource, onLoad, onProgress, onError, onMeshAlter, useAsync );\n  };\n\n  OBJLoader2.prototype._loadObj = function ( resource, onLoad, onProgress, onError, onMeshAlter, useAsync ) {\n    var scope = this;\n    if ( ! Validator.isValid( onError ) ) {\n      onError = function ( event ) {\n        scope._onError( event );\n      };\n    }\n\n    // fast-fail\n    if ( ! Validator.isValid( resource ) ) onError( 'An invalid ResourceDescriptor was provided. Unable to continue!' );\n    var fileLoaderOnLoad = function ( content ) {\n\n      resource.content = content;\n      if ( useAsync ) {\n\n        scope.parseAsync( content, onLoad );\n\n      } else {\n\n        var callbacks = new LoaderSupport.Callbacks();\n        callbacks.setCallbackOnMeshAlter( onMeshAlter );\n        scope._setCallbacks( callbacks );\n        onLoad(\n          {\n            detail: {\n              loaderRootNode: scope.parse( content ),\n              modelName: scope.modelName,\n              instanceNo: scope.instanceNo\n            }\n          }\n        );\n\n      }\n    };\n\n    // fast-fail\n    if ( ! Validator.isValid( resource.url ) || Validator.isValid( resource.content ) ) {\n\n      fileLoaderOnLoad( Validator.isValid( resource.content ) ? resource.content : null );\n\n    } else {\n\n      if ( ! Validator.isValid( onProgress ) ) {\n        var numericalValueRef = 0;\n        var numericalValue = 0;\n        onProgress = function ( event ) {\n          if ( ! event.lengthComputable ) return;\n\n          numericalValue = event.loaded / event.total;\n          if ( numericalValue > numericalValueRef ) {\n\n            numericalValueRef = numericalValue;\n            var output = 'Download of \"' + resource.url + '\": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';\n            scope.onProgress( 'progressLoad', output, numericalValue );\n\n          }\n        };\n      }\n\n\n      var fileLoader = new THREE.FileLoader( this.manager );\n      fileLoader.setPath( this.path );\n      fileLoader.setResponseType( 'arraybuffer' );\n      fileLoader.load( resource.url, fileLoaderOnLoad, onProgress, onError );\n\n    }\n  };\n\n\n  /*\n   * Run the loader according the provided instructions.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {LoaderSupport.PrepData} prepData All parameters and resources required for execution\n   * @param {LoaderSupport.WorkerSupport} [workerSupportExternal] Use pre-existing WorkerSupport\n   */\n  OBJLoader2.prototype.run = function ( prepData, workerSupportExternal ) {\n    this._applyPrepData( prepData );\n    var available = prepData.checkResourceDescriptorFiles( prepData.resources,\n      [\n        { ext: \"obj\", type: \"ArrayBuffer\", ignore: false },\n        { ext: \"mtl\", type: \"String\", ignore: false },\n        { ext: \"zip\", type: \"String\", ignore: true }\n      ]\n    );\n    if ( Validator.isValid( workerSupportExternal ) ) {\n\n      this.terminateWorkerOnLoad = false;\n      this.workerSupport = workerSupportExternal;\n      this.logging.enabled = this.workerSupport.logging.enabled;\n      this.logging.debug = this.workerSupport.logging.debug;\n\n    }\n    var scope = this;\n    var onMaterialsLoaded = function ( materials ) {\n      if ( materials !== null ) scope.meshBuilder.setMaterials( materials );\n      scope._loadObj( available.obj, scope.callbacks.onLoad, null, null, scope.callbacks.onMeshAlter, prepData.useAsync );\n\n    };\n    this._loadMtl( available.mtl, onMaterialsLoaded, null, null, prepData.crossOrigin, prepData.materialOptions );\n  };\n\n  OBJLoader2.prototype._applyPrepData = function ( prepData ) {\n    if ( Validator.isValid( prepData ) ) {\n\n      this.setLogging( prepData.logging.enabled, prepData.logging.debug );\n      this.setModelName( prepData.modelName );\n      this.setStreamMeshesTo( prepData.streamMeshesTo );\n      this.meshBuilder.setMaterials( prepData.materials );\n      this.setUseIndices( prepData.useIndices );\n      this.setDisregardNormals( prepData.disregardNormals );\n      this.setMaterialPerSmoothingGroup( prepData.materialPerSmoothingGroup );\n      this.setUseOAsMesh( prepData.useOAsMesh );\n\n      this._setCallbacks( prepData.getCallbacks() );\n\n    }\n  };\n\n  /*\n   * Parses OBJ data synchronously from arraybuffer or string.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {arraybuffer|string} content OBJ data as Uint8Array or String\n   */\n  OBJLoader2.prototype.parse = function ( content ) {\n    // fast-fail in case of illegal data\n    if ( ! Validator.isValid( content ) ) {\n\n      console.warn( 'Provided content is not a valid ArrayBuffer or String.' );\n      return this.loaderRootNode;\n\n    }\n    if ( this.logging.enabled ) console.time( 'OBJLoader2 parse: ' + this.modelName );\n    this.meshBuilder.init();\n\n    var parser = new Parser();\n    parser.setLogging( this.logging.enabled, this.logging.debug );\n    parser.setMaterialPerSmoothingGroup( this.materialPerSmoothingGroup );\n    parser.setUseOAsMesh( this.useOAsMesh );\n    parser.setUseIndices( this.useIndices );\n    parser.setDisregardNormals( this.disregardNormals );\n    // sync code works directly on the material references\n    parser.setMaterials( this.meshBuilder.getMaterials() );\n\n    var scope = this;\n    var onMeshLoaded = function ( payload ) {\n      var meshes = scope.meshBuilder.processPayload( payload );\n      var mesh;\n      for ( var i in meshes ) {\n        mesh = meshes[ i ];\n        scope.loaderRootNode.add( mesh );\n      }\n    };\n    parser.setCallbackMeshBuilder( onMeshLoaded );\n    var onProgressScoped = function ( text, numericalValue ) {\n      scope.onProgress( 'progressParse', text, numericalValue );\n    };\n    parser.setCallbackProgress( onProgressScoped );\n\n    if ( content instanceof ArrayBuffer || content instanceof Uint8Array ) {\n\n      if ( this.logging.enabled ) console.info( 'Parsing arrayBuffer...' );\n      parser.parse( content );\n\n    } else if ( typeof( content ) === 'string' || content instanceof String ) {\n\n      if ( this.logging.enabled ) console.info( 'Parsing text...' );\n      parser.parseText( content );\n\n    } else {\n\n      this._throwError( 'Provided content was neither of type String nor Uint8Array! Aborting...' );\n\n    }\n    if ( this.logging.enabled ) console.timeEnd( 'OBJLoader2 parse: ' + this.modelName );\n\n    return this.loaderRootNode;\n  };\n\n  /*\n   * Parses OBJ content asynchronously from arraybuffer.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {arraybuffer} content OBJ data as Uint8Array\n   * @param {callback} onLoad Called after worker successfully completed loading\n   */\n  OBJLoader2.prototype.parseAsync = function ( content, onLoad ) {\n    var scope = this;\n    var measureTime = false;\n    var scopedOnLoad = function () {\n      onLoad(\n        {\n          detail: {\n            loaderRootNode: scope.loaderRootNode,\n            modelName: scope.modelName,\n            instanceNo: scope.instanceNo\n          }\n        }\n      );\n      if ( measureTime && scope.logging.enabled ) console.timeEnd( 'OBJLoader2 parseAsync: ' + scope.modelName );\n    };\n    // fast-fail in case of illegal data\n    if ( ! Validator.isValid( content ) ) {\n\n      console.warn( 'Provided content is not a valid ArrayBuffer.' );\n      scopedOnLoad();\n\n    } else {\n\n      measureTime = true;\n\n    }\n    if ( measureTime && this.logging.enabled ) console.time( 'OBJLoader2 parseAsync: ' + this.modelName );\n    this.meshBuilder.init();\n\n    var scopedOnMeshLoaded = function ( payload ) {\n      var meshes = scope.meshBuilder.processPayload( payload );\n      var mesh;\n      for ( var i in meshes ) {\n        mesh = meshes[ i ];\n        scope.loaderRootNode.add( mesh );\n      }\n    };\n    var buildCode = function ( funcBuildObject, funcBuildSingleton ) {\n      var workerCode = '';\n      workerCode += '/*\\n';\n      workerCode += '  * This code was constructed by OBJLoader2 buildCode.\\n';\n      workerCode += '  */\\n\\n';\n      workerCode += 'THREE = { LoaderSupport: {} };\\n\\n';\n      workerCode += funcBuildObject( 'LoaderSupport.Validator', Validator );\n      workerCode += funcBuildSingleton( 'Parser', Parser );\n\n      return workerCode;\n    };\n    this.workerSupport.validate( buildCode, 'Parser' );\n    this.workerSupport.setCallbacks( scopedOnMeshLoaded, scopedOnLoad );\n    if ( scope.terminateWorkerOnLoad ) this.workerSupport.setTerminateRequested( true );\n\n    var materialNames = {};\n    var materials = this.meshBuilder.getMaterials();\n    for ( var materialName in materials ) {\n\n      materialNames[ materialName ] = materialName;\n\n    }\n    this.workerSupport.run(\n      {\n        params: {\n          useAsync: true,\n          materialPerSmoothingGroup: this.materialPerSmoothingGroup,\n          useOAsMesh: this.useOAsMesh,\n          useIndices: this.useIndices,\n          disregardNormals: this.disregardNormals\n        },\n        logging: {\n          enabled: this.logging.enabled,\n          debug: this.logging.debug\n        },\n        materials: {\n          // in async case only material names are supplied to parser\n          materials: materialNames\n        },\n        data: {\n          input: content,\n          options: null\n        }\n      }\n    );\n  };\n\n\n  /*\n   * Parse OBJ data either from ArrayBuffer or string\n   * @class\n   */\n  var Parser = (function () {\n\n    function Parser() {\n      this.callbackProgress = null;\n      this.callbackMeshBuilder = null;\n      this.contentRef = null;\n      this.legacyMode = false;\n\n      this.materials = {};\n      this.useAsync = false;\n      this.materialPerSmoothingGroup = false;\n      this.useOAsMesh = false;\n      this.useIndices = false;\n      this.disregardNormals = false;\n\n      this.vertices = [];\n      this.colors = [];\n      this.normals = [];\n      this.uvs = [];\n\n      this.rawMesh = {\n        objectName: '',\n        groupName: '',\n        activeMtlName: '',\n        mtllibName: '',\n\n        // reset with new mesh\n        faceType: -1,\n        subGroups: [],\n        subGroupInUse: null,\n        smoothingGroup: {\n          splitMaterials: false,\n          normalized: -1,\n          real: -1\n        },\n        counts: {\n          doubleIndicesCount: 0,\n          faceCount: 0,\n          mtlCount: 0,\n          smoothingGroupCount: 0\n        }\n      };\n\n      this.inputObjectCount = 1;\n      this.outputObjectCount = 1;\n      this.globalCounts = {\n        vertices: 0,\n        faces: 0,\n        doubleIndicesCount: 0,\n        lineByte: 0,\n        currentByte: 0,\n        totalBytes: 0\n      };\n\n      this.logging = {\n        enabled: true,\n        debug: false\n      };\n    }\n\n    Parser.prototype.resetRawMesh = function () {\n      // faces are stored according combined index of group, material and smoothingGroup (0 or not)\n      this.rawMesh.subGroups = [];\n      this.rawMesh.subGroupInUse = null;\n      this.rawMesh.smoothingGroup.normalized = -1;\n      this.rawMesh.smoothingGroup.real = -1;\n\n      // this default index is required as it is possible to define faces without 'g' or 'usemtl'\n      this.pushSmoothingGroup( 1 );\n\n      this.rawMesh.counts.doubleIndicesCount = 0;\n      this.rawMesh.counts.faceCount = 0;\n      this.rawMesh.counts.mtlCount = 0;\n      this.rawMesh.counts.smoothingGroupCount = 0;\n    };\n\n    Parser.prototype.setUseAsync = function ( useAsync ) {\n      this.useAsync = useAsync;\n    };\n\n    Parser.prototype.setMaterialPerSmoothingGroup = function ( materialPerSmoothingGroup ) {\n      this.materialPerSmoothingGroup = materialPerSmoothingGroup;\n    };\n\n    Parser.prototype.setUseOAsMesh = function ( useOAsMesh ) {\n      this.useOAsMesh = useOAsMesh;\n    };\n\n    Parser.prototype.setUseIndices = function ( useIndices ) {\n      this.useIndices = useIndices;\n    };\n\n    Parser.prototype.setDisregardNormals = function ( disregardNormals ) {\n      this.disregardNormals = disregardNormals;\n    };\n\n    Parser.prototype.setMaterials = function ( materials ) {\n      this.materials = LoaderSupport.Validator.verifyInput( materials, this.materials );\n      this.materials = LoaderSupport.Validator.verifyInput( this.materials, {} );\n    };\n\n    Parser.prototype.setCallbackMeshBuilder = function ( callbackMeshBuilder ) {\n      if ( ! LoaderSupport.Validator.isValid( callbackMeshBuilder ) ) {\n\n        this._throwError( 'Unable to run as no \"MeshBuilder\" callback is set.' );\n\n      }\n      this.callbackMeshBuilder = callbackMeshBuilder;\n    };\n\n    Parser.prototype.setCallbackProgress = function ( callbackProgress ) {\n      this.callbackProgress = callbackProgress;\n    };\n\n    Parser.prototype.setLogging = function ( enabled, debug ) {\n      this.logging.enabled = enabled === true;\n      this.logging.debug = debug === true;\n    };\n\n    Parser.prototype.configure = function () {\n      this.pushSmoothingGroup( 1 );\n\n      if ( this.logging.enabled ) {\n\n        var matKeys = Object.keys( this.materials );\n        var matNames = ( matKeys.length > 0 ) ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join( '\\n\\t\\t- ' ) : '\\n\\tmaterialNames: None';\n        var printedConfig = 'OBJLoader2.Parser configuration:'\n          + matNames\n          + '\\n\\tuseAsync: ' + this.useAsync\n          + '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup\n          + '\\n\\tuseOAsMesh: ' + this.useOAsMesh\n          + '\\n\\tuseIndices: ' + this.useIndices\n          + '\\n\\tdisregardNormals: ' + this.disregardNormals\n          + '\\n\\tcallbackMeshBuilderName: ' + this.callbackMeshBuilder.name\n          + '\\n\\tcallbackProgressName: ' + this.callbackProgress.name;\n        console.info( printedConfig );\n      }\n    };\n\n    /*\n     * Parse the provided arraybuffer\n     * @memberOf Parser\n     *\n     * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n     */\n    Parser.prototype.parse = function ( arrayBuffer ) {\n      if ( this.logging.enabled ) console.time( 'OBJLoader2.Parser.parse' );\n      this.configure();\n\n      var arrayBufferView = new Uint8Array( arrayBuffer );\n      this.contentRef = arrayBufferView;\n      var length = arrayBufferView.byteLength;\n      this.globalCounts.totalBytes = length;\n      var buffer = new Array( 128 );\n\n      for ( var code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++ ) {\n\n        code = arrayBufferView[ i ];\n        switch ( code ) {\n          // space\n          case 32:\n            if ( word.length > 0 ) buffer[ bufferPointer++ ] = word;\n            word = '';\n            break;\n          // slash\n          case 47:\n            if ( word.length > 0 ) buffer[ bufferPointer++ ] = word;\n            slashesCount++;\n            word = '';\n            break;\n\n          // LF\n          case 10:\n            if ( word.length > 0 ) buffer[ bufferPointer++ ] = word;\n            word = '';\n            this.globalCounts.lineByte = this.globalCounts.currentByte;\n            this.globalCounts.currentByte = i;\n            this.processLine( buffer, bufferPointer, slashesCount );\n            bufferPointer = 0;\n            slashesCount = 0;\n            break;\n\n          // CR\n          case 13:\n            break;\n\n          default:\n            word += String.fromCharCode( code );\n            break;\n        }\n      }\n      this.finalizeParsing();\n      if ( this.logging.enabled ) console.timeEnd(  'OBJLoader2.Parser.parse' );\n    };\n\n    /*\n     * Parse the provided text\n     * @memberOf Parser\n     *\n     * @param {string} text OBJ data as string\n     */\n    Parser.prototype.parseText = function ( text ) {\n      if ( this.logging.enabled ) console.time(  'OBJLoader2.Parser.parseText' );\n      this.configure();\n      this.legacyMode = true;\n      this.contentRef = text;\n      var length = text.length;\n      this.globalCounts.totalBytes = length;\n      var buffer = new Array( 128 );\n\n      for ( var char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i++ ) {\n\n        char = text[ i ];\n        switch ( char ) {\n          case ' ':\n            if ( word.length > 0 ) buffer[ bufferPointer++ ] = word;\n            word = '';\n            break;\n\n          case '/':\n            if ( word.length > 0 ) buffer[ bufferPointer++ ] = word;\n            slashesCount++;\n            word = '';\n            break;\n\n          case '\\n':\n            if ( word.length > 0 ) buffer[ bufferPointer++ ] = word;\n            word = '';\n            this.globalCounts.lineByte = this.globalCounts.currentByte;\n            this.globalCounts.currentByte = i;\n            this.processLine( buffer, bufferPointer, slashesCount );\n            bufferPointer = 0;\n            slashesCount = 0;\n            break;\n\n          case '\\r':\n            break;\n\n          default:\n            word += char;\n        }\n      }\n      this.finalizeParsing();\n      if ( this.logging.enabled ) console.timeEnd( 'OBJLoader2.Parser.parseText' );\n    };\n\n    Parser.prototype.processLine = function ( buffer, bufferPointer, slashesCount ) {\n      if ( bufferPointer < 1 ) return;\n\n      var reconstructString = function ( content, legacyMode, start, stop ) {\n        var line = '';\n        if ( stop > start ) {\n\n          var i;\n          if ( legacyMode ) {\n\n            for ( i = start; i < stop; i++ ) line += content[ i ];\n\n          } else {\n\n\n            for ( i = start; i < stop; i++ ) line += String.fromCharCode( content[ i ] );\n\n          }\n          line = line.trim();\n\n        }\n        return line;\n      };\n\n      var bufferLength, length, i, lineDesignation;\n      lineDesignation = buffer [ 0 ];\n      switch ( lineDesignation ) {\n        case 'v':\n          this.vertices.push( parseFloat( buffer[ 1 ] ) );\n          this.vertices.push( parseFloat( buffer[ 2 ] ) );\n          this.vertices.push( parseFloat( buffer[ 3 ] ) );\n          if ( bufferPointer > 4 ) {\n\n            this.colors.push( parseFloat( buffer[ 4 ] ) );\n            this.colors.push( parseFloat( buffer[ 5 ] ) );\n            this.colors.push( parseFloat( buffer[ 6 ] ) );\n\n          }\n          break;\n\n        case 'vt':\n          this.uvs.push( parseFloat( buffer[ 1 ] ) );\n          this.uvs.push( parseFloat( buffer[ 2 ] ) );\n          break;\n\n        case 'vn':\n          this.normals.push( parseFloat( buffer[ 1 ] ) );\n          this.normals.push( parseFloat( buffer[ 2 ] ) );\n          this.normals.push( parseFloat( buffer[ 3 ] ) );\n          break;\n\n        case 'f':\n          bufferLength = bufferPointer - 1;\n\n          // \"f vertex ...\"\n          if ( slashesCount === 0 ) {\n\n            this.checkFaceType( 0 );\n            for ( i = 2, length = bufferLength; i < length; i ++ ) {\n\n              this.buildFace( buffer[ 1 ] );\n              this.buildFace( buffer[ i ] );\n              this.buildFace( buffer[ i + 1 ] );\n\n            }\n\n          // \"f vertex/uv ...\"\n          } else if  ( bufferLength === slashesCount * 2 ) {\n\n            this.checkFaceType( 1 );\n            for ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n              this.buildFace( buffer[ 1 ], buffer[ 2 ] );\n              this.buildFace( buffer[ i ], buffer[ i + 1 ] );\n              this.buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );\n\n            }\n\n          // \"f vertex/uv/normal ...\"\n          } else if  ( bufferLength * 2 === slashesCount * 3 ) {\n\n            this.checkFaceType( 2 );\n            for ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {\n\n              this.buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );\n              this.buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );\n              this.buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );\n\n            }\n\n          // \"f vertex//normal ...\"\n          } else {\n\n            this.checkFaceType( 3 );\n            for ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n              this.buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );\n              this.buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );\n              this.buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );\n\n            }\n\n          }\n          break;\n\n        case 'l':\n        case 'p':\n          bufferLength = bufferPointer - 1;\n          if ( bufferLength === slashesCount * 2 )  {\n\n            this.checkFaceType( 4 );\n            for ( i = 1, length = bufferLength + 1; i < length; i += 2 ) this.buildFace( buffer[ i ], buffer[ i + 1 ] );\n\n          } else {\n\n            this.checkFaceType( ( lineDesignation === 'l' ) ? 5 : 6  );\n            for ( i = 1, length = bufferLength + 1; i < length; i ++ ) this.buildFace( buffer[ i ] );\n\n          }\n          break;\n\n        case 's':\n          this.pushSmoothingGroup( buffer[ 1 ] );\n          break;\n\n        case 'g':\n          // 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n          this.processCompletedMesh();\n          this.rawMesh.groupName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n          break;\n\n        case 'o':\n          // 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\n          if ( this.useOAsMesh ) this.processCompletedMesh();\n          this.rawMesh.objectName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n          break;\n\n        case 'mtllib':\n          this.rawMesh.mtllibName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n          break;\n\n        case 'usemtl':\n          var mtlName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n          if ( mtlName !== '' && this.rawMesh.activeMtlName !== mtlName ) {\n\n            this.rawMesh.activeMtlName = mtlName;\n            this.rawMesh.counts.mtlCount++;\n            this.checkSubGroup();\n\n          }\n          break;\n\n        default:\n          break;\n      }\n    };\n\n    Parser.prototype.pushSmoothingGroup = function ( smoothingGroup ) {\n      var smoothingGroupInt = parseInt( smoothingGroup );\n      if ( isNaN( smoothingGroupInt ) ) {\n        smoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n      }\n\n      var smoothCheck = this.rawMesh.smoothingGroup.normalized;\n      this.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;\n      this.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n      if ( smoothCheck !== smoothingGroupInt ) {\n\n        this.rawMesh.counts.smoothingGroupCount++;\n        this.checkSubGroup();\n\n      }\n    };\n\n    /*\n     * Expanded faceTypes include all four face types, both line types and the point type\n     * faceType = 0: \"f vertex ...\"\n     * faceType = 1: \"f vertex/uv ...\"\n     * faceType = 2: \"f vertex/uv/normal ...\"\n     * faceType = 3: \"f vertex//normal ...\"\n     * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n     * faceType = 5: \"l vertex ...\"\n     * faceType = 6: \"p vertex ...\"\n     */\n    Parser.prototype.checkFaceType = function ( faceType ) {\n      if ( this.rawMesh.faceType !== faceType ) {\n\n        this.processCompletedMesh();\n        this.rawMesh.faceType = faceType;\n        this.checkSubGroup();\n\n      }\n    };\n\n    Parser.prototype.checkSubGroup = function () {\n      var index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n      this.rawMesh.subGroupInUse = this.rawMesh.subGroups[ index ];\n\n      if ( ! LoaderSupport.Validator.isValid( this.rawMesh.subGroupInUse ) ) {\n\n        this.rawMesh.subGroupInUse = {\n          index: index,\n          objectName: this.rawMesh.objectName,\n          groupName: this.rawMesh.groupName,\n          materialName: this.rawMesh.activeMtlName,\n          smoothingGroup: this.rawMesh.smoothingGroup.normalized,\n          vertices: [],\n          indexMappingsCount: 0,\n          indexMappings: [],\n          indices: [],\n          colors: [],\n          uvs: [],\n          normals: []\n        };\n        this.rawMesh.subGroups[ index ] = this.rawMesh.subGroupInUse;\n\n      }\n    };\n\n    Parser.prototype.buildFace = function ( faceIndexV, faceIndexU, faceIndexN ) {\n      if ( this.disregardNormals ) faceIndexN = undefined;\n      var scope = this;\n      var updateSubGroupInUse = function () {\n\n        var faceIndexVi = parseInt( faceIndexV );\n        var indexPointerV = 3 * ( faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3 );\n\n        var vertices = scope.rawMesh.subGroupInUse.vertices;\n        vertices.push( scope.vertices[ indexPointerV++ ] );\n        vertices.push( scope.vertices[ indexPointerV++ ] );\n        vertices.push( scope.vertices[ indexPointerV ] );\n\n        var indexPointerC = scope.colors.length > 0 ? indexPointerV + 1 : null;\n        if ( indexPointerC !== null ) {\n\n          var colors = scope.rawMesh.subGroupInUse.colors;\n          colors.push( scope.colors[ indexPointerC++ ] );\n          colors.push( scope.colors[ indexPointerC++ ] );\n          colors.push( scope.colors[ indexPointerC ] );\n\n        }\n        if ( faceIndexU ) {\n\n          var faceIndexUi = parseInt( faceIndexU );\n          var indexPointerU = 2 * ( faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2 );\n          var uvs = scope.rawMesh.subGroupInUse.uvs;\n          uvs.push( scope.uvs[ indexPointerU++ ] );\n          uvs.push( scope.uvs[ indexPointerU ] );\n\n        }\n        if ( faceIndexN ) {\n\n          var faceIndexNi = parseInt( faceIndexN );\n          var indexPointerN = 3 * ( faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3 );\n          var normals = scope.rawMesh.subGroupInUse.normals;\n          normals.push( scope.normals[ indexPointerN++ ] );\n          normals.push( scope.normals[ indexPointerN++ ] );\n          normals.push( scope.normals[ indexPointerN ] );\n\n        }\n      };\n\n      if ( this.useIndices ) {\n\n        var mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );\n        var indicesPointer = this.rawMesh.subGroupInUse.indexMappings[ mappingName ];\n        if ( LoaderSupport.Validator.isValid( indicesPointer ) ) {\n\n          this.rawMesh.counts.doubleIndicesCount++;\n\n        } else {\n\n          indicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n          updateSubGroupInUse();\n          this.rawMesh.subGroupInUse.indexMappings[ mappingName ] = indicesPointer;\n          this.rawMesh.subGroupInUse.indexMappingsCount++;\n\n        }\n        this.rawMesh.subGroupInUse.indices.push( indicesPointer );\n\n      } else {\n\n        updateSubGroupInUse();\n\n      }\n      this.rawMesh.counts.faceCount++;\n    };\n\n    Parser.prototype.createRawMeshReport = function ( inputObjectCount ) {\n      return 'Input Object number: ' + inputObjectCount +\n        '\\n\\tObject name: ' + this.rawMesh.objectName +\n        '\\n\\tGroup name: ' + this.rawMesh.groupName +\n        '\\n\\tMtllib name: ' + this.rawMesh.mtllibName +\n        '\\n\\tVertex count: ' + this.vertices.length / 3 +\n        '\\n\\tNormal count: ' + this.normals.length / 3 +\n        '\\n\\tUV count: ' + this.uvs.length / 2 +\n        '\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount +\n        '\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount +\n        '\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n    };\n\n    /*\n     * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n     */\n    Parser.prototype.finalizeRawMesh = function () {\n      var meshOutputGroupTemp = [];\n      var meshOutputGroup;\n      var absoluteVertexCount = 0;\n      var absoluteIndexMappingsCount = 0;\n      var absoluteIndexCount = 0;\n      var absoluteColorCount = 0;\n      var absoluteNormalCount = 0;\n      var absoluteUvCount = 0;\n      var indices;\n      for ( var name in this.rawMesh.subGroups ) {\n\n        meshOutputGroup = this.rawMesh.subGroups[ name ];\n        if ( meshOutputGroup.vertices.length > 0 ) {\n\n          indices = meshOutputGroup.indices;\n          if ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {\n\n            for ( var i in indices ) indices[ i ] = indices[ i ] + absoluteIndexMappingsCount;\n\n          }\n          meshOutputGroupTemp.push( meshOutputGroup );\n          absoluteVertexCount += meshOutputGroup.vertices.length;\n          absoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n          absoluteIndexCount += meshOutputGroup.indices.length;\n          absoluteColorCount += meshOutputGroup.colors.length;\n          absoluteUvCount += meshOutputGroup.uvs.length;\n          absoluteNormalCount += meshOutputGroup.normals.length;\n\n        }\n      }\n\n      // do not continue if no result\n      var result = null;\n      if ( meshOutputGroupTemp.length > 0 ) {\n\n        result = {\n          name: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n          subGroups: meshOutputGroupTemp,\n          absoluteVertexCount: absoluteVertexCount,\n          absoluteIndexCount: absoluteIndexCount,\n          absoluteColorCount: absoluteColorCount,\n          absoluteNormalCount: absoluteNormalCount,\n          absoluteUvCount: absoluteUvCount,\n          faceCount: this.rawMesh.counts.faceCount,\n          doubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n        };\n\n      }\n      return result;\n    };\n\n    Parser.prototype.processCompletedMesh = function () {\n      var result = this.finalizeRawMesh();\n      if ( LoaderSupport.Validator.isValid( result ) ) {\n\n        if ( this.colors.length > 0 && this.colors.length !== this.vertices.length ) {\n\n          this._throwError( 'Vertex Colors were detected, but vertex count and color count do not match!' );\n\n        }\n        if ( this.logging.enabled && this.logging.debug ) console.debug( this.createRawMeshReport( this.inputObjectCount ) );\n        this.inputObjectCount++;\n\n        this.buildMesh( result );\n        var progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n        this.callbackProgress( 'Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '] Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%', progressBytesPercent );\n        this.resetRawMesh();\n        return true;\n\n      } else {\n\n        return false;\n      }\n    };\n\n    /*\n     * SubGroups are transformed to too intermediate format that is forwarded to the MeshBuilder.\n     * It is ensured that SubGroups only contain objects with vertices (no need to check).\n     *\n     * @param result\n     */\n    Parser.prototype.buildMesh = function ( result ) {\n      var meshOutputGroups = result.subGroups;\n\n      var vertexFA = new Float32Array( result.absoluteVertexCount );\n      this.globalCounts.vertices += result.absoluteVertexCount / 3;\n      this.globalCounts.faces += result.faceCount;\n      this.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n      var indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;\n      var colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;\n      var normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;\n      var uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;\n      var haveVertexColors = LoaderSupport.Validator.isValid( colorFA );\n\n      var meshOutputGroup;\n      var materialNames = [];\n\n      var createMultiMaterial = ( meshOutputGroups.length > 1 );\n      var materialIndex = 0;\n      var materialIndexMapping = [];\n      var selectedMaterialIndex;\n      var materialGroup;\n      var materialGroups = [];\n\n      var vertexFAOffset = 0;\n      var indexUAOffset = 0;\n      var colorFAOffset = 0;\n      var normalFAOffset = 0;\n      var uvFAOffset = 0;\n      var materialGroupOffset = 0;\n      var materialGroupLength = 0;\n\n      var materialOrg, material, materialName, materialNameOrg;\n      // only one specific face type\n      for ( var oodIndex in meshOutputGroups ) {\n\n        if ( ! meshOutputGroups.hasOwnProperty( oodIndex ) ) continue;\n        meshOutputGroup = meshOutputGroups[ oodIndex ];\n\n        materialNameOrg = meshOutputGroup.materialName;\n        if ( this.rawMesh.faceType < 4 ) {\n\n          materialName = materialNameOrg + ( haveVertexColors ? '_vertexColor' : '' ) + ( meshOutputGroup.smoothingGroup === 0 ? '_flat' : '' );\n\n\n        } else {\n\n          materialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n\n        }\n        materialOrg = this.materials[ materialNameOrg ];\n        material = this.materials[ materialName ];\n\n        // both original and derived names do not lead to an existing material => need to use a default material\n        if ( ! LoaderSupport.Validator.isValid( materialOrg ) && ! LoaderSupport.Validator.isValid( material ) ) {\n\n          var defaultMaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n          materialOrg = this.materials[ defaultMaterialName ];\n          if ( this.logging.enabled ) console.warn( 'object_group \"' + meshOutputGroup.objectName + '_' +\n            meshOutputGroup.groupName + '\" was defined with unresolvable material \"' +\n            materialNameOrg + '\"! Assigning \"' + defaultMaterialName + '\".' );\n          materialNameOrg = defaultMaterialName;\n\n          // if names are identical then there is no need for later manipulation\n          if ( materialNameOrg === materialName ) {\n\n            material = materialOrg;\n            materialName = defaultMaterialName;\n\n          }\n\n        }\n        if ( ! LoaderSupport.Validator.isValid( material ) ) {\n\n          var materialCloneInstructions = {\n            materialNameOrg: materialNameOrg,\n            materialName: materialName,\n            materialProperties: {\n              vertexColors: haveVertexColors ? 2 : 0,\n              flatShading: meshOutputGroup.smoothingGroup === 0\n            }\n          };\n          var payload = {\n            cmd: 'materialData',\n            materials: {\n              materialCloneInstructions: materialCloneInstructions\n            }\n          };\n          this.callbackMeshBuilder( payload );\n\n          // fake entry for async; sync Parser always works on material references (Builder update directly visible here)\n          if ( this.useAsync ) this.materials[ materialName ] = materialCloneInstructions;\n\n        }\n\n        if ( createMultiMaterial ) {\n\n          // re-use material if already used before. Reduces materials array size and eliminates duplicates\n          selectedMaterialIndex = materialIndexMapping[ materialName ];\n          if ( ! selectedMaterialIndex ) {\n\n            selectedMaterialIndex = materialIndex;\n            materialIndexMapping[ materialName ] = materialIndex;\n            materialNames.push( materialName );\n            materialIndex++;\n\n          }\n          materialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n          materialGroup = {\n            start: materialGroupOffset,\n            count: materialGroupLength,\n            index: selectedMaterialIndex\n          };\n          materialGroups.push( materialGroup );\n          materialGroupOffset += materialGroupLength;\n\n        } else {\n\n          materialNames.push( materialName );\n\n        }\n\n        vertexFA.set( meshOutputGroup.vertices, vertexFAOffset );\n        vertexFAOffset += meshOutputGroup.vertices.length;\n\n        if ( indexUA ) {\n\n          indexUA.set( meshOutputGroup.indices, indexUAOffset );\n          indexUAOffset += meshOutputGroup.indices.length;\n\n        }\n\n        if ( colorFA ) {\n\n          colorFA.set( meshOutputGroup.colors, colorFAOffset );\n          colorFAOffset += meshOutputGroup.colors.length;\n\n        }\n\n        if ( normalFA ) {\n\n          normalFA.set( meshOutputGroup.normals, normalFAOffset );\n          normalFAOffset += meshOutputGroup.normals.length;\n\n        }\n        if ( uvFA ) {\n\n          uvFA.set( meshOutputGroup.uvs, uvFAOffset );\n          uvFAOffset += meshOutputGroup.uvs.length;\n\n        }\n\n        if ( this.logging.enabled && this.logging.debug ) {\n          var materialIndexLine = LoaderSupport.Validator.isValid( selectedMaterialIndex ) ? '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex : '';\n          var createdReport = '\\tOutput Object no.: ' + this.outputObjectCount +\n            '\\n\\t\\tgroupName: ' + meshOutputGroup.groupName +\n            '\\n\\t\\tIndex: ' + meshOutputGroup.index +\n            '\\n\\t\\tfaceType: ' + this.rawMesh.faceType +\n            '\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName +\n            '\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup +\n            materialIndexLine +\n            '\\n\\t\\tobjectName: ' + meshOutputGroup.objectName +\n            '\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 +\n            '\\n\\t\\t#indices: ' + meshOutputGroup.indices.length +\n            '\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 +\n            '\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 +\n            '\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n          console.debug( createdReport );\n        }\n\n      }\n\n      this.outputObjectCount++;\n      this.callbackMeshBuilder(\n        {\n          cmd: 'meshData',\n          progress: {\n            numericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n          },\n          params: {\n            meshName: result.name\n          },\n          materials: {\n            multiMaterial: createMultiMaterial,\n            materialNames: materialNames,\n            materialGroups: materialGroups\n          },\n          buffers: {\n            vertices: vertexFA,\n            indices: indexUA,\n            colors: colorFA,\n            normals: normalFA,\n            uvs: uvFA\n          },\n          // 0: mesh, 1: line, 2: point\n          geometryType: this.rawMesh.faceType < 4 ? 0 : ( this.rawMesh.faceType === 6 ) ? 2 : 1\n        },\n        [ vertexFA.buffer ],\n        LoaderSupport.Validator.isValid( indexUA ) ? [ indexUA.buffer ] : null,\n        LoaderSupport.Validator.isValid( colorFA ) ? [ colorFA.buffer ] : null,\n        LoaderSupport.Validator.isValid( normalFA ) ? [ normalFA.buffer ] : null,\n        LoaderSupport.Validator.isValid( uvFA ) ? [ uvFA.buffer ] : null\n      );\n    };\n\n    Parser.prototype.finalizeParsing = function () {\n      if ( this.logging.enabled ) console.info( 'Global output object count: ' + this.outputObjectCount );\n      if ( this.processCompletedMesh() && this.logging.enabled ) {\n\n        var parserFinalReport = 'Overall counts: ' +\n          '\\n\\tVertices: ' + this.globalCounts.vertices +\n          '\\n\\tFaces: ' + this.globalCounts.faces +\n          '\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n        console.info( parserFinalReport );\n\n      }\n    };\n\n    return Parser;\n  })();\n\n  /*\n   * Utility method for loading an mtl file according resource description. Provide url or content.\n   * @memberOf THREE.OBJLoader2\n   *\n   * @param {string} url URL to the file\n   * @param {Object} content The file content as arraybuffer or text\n   * @param {function} onLoad Callback to be called after successful load\n   * @param {callback} [onProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n   * @param {callback} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n   * @param {string} [crossOrigin] CORS value\n    * @param {Object} [materialOptions] Set material loading options for MTLLoader\n   */\n  OBJLoader2.prototype.loadMtl = function ( url, content, onLoad, onProgress, onError, crossOrigin, materialOptions ) {\n    var resource = new LoaderSupport.ResourceDescriptor( url, 'MTL' );\n    resource.setContent( content );\n    this._loadMtl( resource, onLoad, onProgress, onError, crossOrigin, materialOptions );\n  };\n\n\n  OBJLoader2.prototype._loadMtl = function ( resource, onLoad, onProgress, onError, crossOrigin, materialOptions ) {\n    if ( THREE.MTLLoader === undefined ) console.error( '\"THREE.MTLLoader\" is not available. \"THREE.OBJLoader2\" requires it for loading MTL files.' );\n    if ( Validator.isValid( resource ) && this.logging.enabled ) console.time( 'Loading MTL: ' + resource.name );\n\n    var materials = [];\n    var scope = this;\n    var processMaterials = function ( materialCreator ) {\n      var materialCreatorMaterials = [];\n      if ( Validator.isValid( materialCreator ) ) {\n\n        materialCreator.preload();\n        materialCreatorMaterials = materialCreator.materials;\n        for ( var materialName in materialCreatorMaterials ) {\n\n          if ( materialCreatorMaterials.hasOwnProperty( materialName ) ) {\n\n            materials[ materialName ] = materialCreatorMaterials[ materialName ];\n\n          }\n        }\n      }\n\n      if ( Validator.isValid( resource ) && scope.logging.enabled ) console.timeEnd( 'Loading MTL: ' + resource.name );\n      onLoad( materials, materialCreator );\n    };\n\n    // fast-fail\n    if ( ! Validator.isValid( resource ) || ( ! Validator.isValid( resource.content ) && ! Validator.isValid( resource.url ) ) ) {\n\n      processMaterials();\n\n    } else {\n\n      var mtlLoader = new THREE.MTLLoader( this.manager );\n      crossOrigin = Validator.verifyInput( crossOrigin, 'anonymous' );\n      mtlLoader.setCrossOrigin( crossOrigin );\n      mtlLoader.setResourcePath( resource.path );\n      if ( Validator.isValid( materialOptions ) ) mtlLoader.setMaterialOptions( materialOptions );\n\n      var parseTextWithMtlLoader = function ( content ) {\n        var contentAsText = content;\n        if ( typeof( content ) !== 'string' && ! ( content instanceof String ) ) {\n\n          if ( content.length > 0 || content.byteLength > 0 ) {\n\n            contentAsText = THREE.LoaderUtils.decodeText( content );\n\n          } else {\n\n            this._throwError( 'Unable to parse mtl as it it seems to be neither a String, an Array or an ArrayBuffer!' );\n          }\n\n        }\n        processMaterials( mtlLoader.parse( contentAsText ) );\n      };\n\n      if ( Validator.isValid( resource.content ) ) {\n\n        parseTextWithMtlLoader( resource.content );\n\n      } else if ( Validator.isValid( resource.url ) ) {\n\n        var fileLoader = new THREE.FileLoader( this.manager );\n        if ( ! Validator.isValid( onError ) ) {\n          onError = function ( event ) {\n            scope._onError( event );\n          };\n        }\n        if ( ! Validator.isValid( onProgress ) ) {\n          var numericalValueRef = 0;\n          var numericalValue = 0;\n          onProgress = function ( event ) {\n            if ( ! event.lengthComputable ) return;\n\n            numericalValue = event.loaded / event.total;\n            if ( numericalValue > numericalValueRef ) {\n\n              numericalValueRef = numericalValue;\n              var output = 'Download of \"' + resource.url + '\": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';\n              scope.onProgress( 'progressLoad', output, numericalValue );\n\n            }\n          };\n        }\n\n        fileLoader.load( resource.url, parseTextWithMtlLoader, onProgress, onError );\n\n      }\n    }\n  };\n\n  return OBJLoader2;\n})();\n\n\nexport default OBJLoader2\n","import * as THREE from 'three'\nimport TrackballControls from './thirdparty/TrackballControls'\nimport STLLoader from './thirdparty/STLLoader'\nimport Tools from './Tools'\nimport EventManager from './EventManager'\nimport OBJLoader2 from './thirdparty/OBJLoader2'\n\n// eslint thing\n/* global window requestAnimationFrame cancelAnimationFrame */\n\n\nconst DEFAULT_FOCUS_DISTANCE = 1000\n\n/**\n * ThreeContext creates a WebGL context using THREEjs. It also handle mouse control.\n * A MorphologyPolyline instance is added to it.\n * An event can be associated to a ThreeContext instance: `onRaycast` with the method\n * `.on(\"onRaycast\", function(s){...})` where `s` is the section object being raycasted.\n */\nclass ThreeContext extends EventManager {\n  /**\n   * @param {DONObject} divObj - the div object as a DOM element.\n   * Will be used to host the WebGL context\n   * created by THREE\n   */\n  constructor(divObj = null) {\n    super()\n\n    const that = this\n\n    if (!divObj) {\n      console.error('The ThreeContext needs a div object')\n      return\n    }\n\n    this._requestFrameId = null\n\n    this._morphologyMeshCollection = {}\n    this._meshCollection = {}\n\n    // init camera\n    this._camera = new THREE.PerspectiveCamera(27, divObj.clientWidth / divObj.clientHeight, 1, 1000000)\n    this._camera.position.z = DEFAULT_FOCUS_DISTANCE\n\n\n    // init scene\n    this._scene = new THREE.Scene()\n    this._scene.add(new THREE.AmbientLight(0x444444))\n\n    // var axesHelper = new THREE.AxesHelper( 1000 )\n    // this._scene.add( axesHelper )\n\n    // adding some light\n    const light1 = new THREE.DirectionalLight(0xffffff, 0.5)\n    light1.position.set(0, 1000, 0)\n    // adding the light to the camera ensure a constant lightin of the model\n    this._scene.add(this._camera)\n    this._camera.add(light1)\n\n    this._renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, preserveDrawingBuffer: true })\n    this._renderer.setClearColor(0xffffff, 0)\n    this._renderer.setPixelRatio(window.devicePixelRatio)\n    this._renderer.setSize(divObj.clientWidth, divObj.clientHeight)\n    this._renderer.gammaInput = true\n    this._renderer.gammaOutput = true\n    divObj.appendChild(this._renderer.domElement)\n\n    // all the necessary for raycasting\n    this._raycaster = new THREE.Raycaster()\n    this._raycastMouse = new THREE.Vector2()\n\n    function onMouseMove(event) {\n      const elem = that._renderer.domElement\n      const relX = event.pageX - elem.offsetLeft\n      const relY = event.pageY - elem.offsetTop\n\n      that._raycastMouse.x = (relX / that._renderer.domElement.clientWidth) * 2 - 1\n      that._raycastMouse.y = -(relY / that._renderer.domElement.clientHeight) * 2 + 1\n    }\n\n    this._renderer.domElement.addEventListener('mousemove', onMouseMove, false)\n    this._renderer.domElement.addEventListener('dblclick', () => {\n      this._performRaycast()\n    }, false)\n\n    // mouse controls\n    this._controls = new TrackballControls(this._camera, this._renderer.domElement)\n    this._controls.rotateSpeed = 3\n    this._controls.addEventListener('change', this._render.bind(this))\n\n    window.addEventListener('resize', () => {\n      that._camera.aspect = divObj.clientWidth / divObj.clientHeight\n      that._camera.updateProjectionMatrix()\n      that._renderer.setSize(divObj.clientWidth, divObj.clientHeight)\n      that._controls.handleResize()\n      that._render()\n    }, false)\n\n    this._testObjMesh()\n\n    this._render()\n    this._animate()\n  }\n\n\n  _testObjMesh () {\n    OBJLoader2\n  }\n\n\n\n  /**\n   * Get the field of view angle of the camera, in degrees\n   * @return {Number}\n   */\n  getCameraFieldOfView() {\n    return this._camera.fov\n  }\n\n\n  /**\n   * Define the camera field of view, in degrees\n   * @param {Number} fov - the fov\n   */\n  setCameraFieldOfView(fov) {\n    this._camera.fov = fov\n    this._camera.updateProjectionMatrix()\n    this._render()\n  }\n\n\n  /**\n   * Adds a mesh from its URL. The mesh has to encoded into the STL format\n   * @param {String} url - the url of the STL file\n   * @param {Object} options - the options object\n   * @param {String} options.name - optional name of this mesh (useful for further operations such as centering the view)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added mesh. If false, the camera will not change\n   * @param {Number} options.opacity - the opacity of the mesh\n   * @param {Number} options.color - the color of the mesh\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Function} options.onDone - callback to be called when the mesh is added. Called with the name of the mesh in argument\n   */\n  addStlToMeshCollection(url, options) {\n    const that = this\n\n    // generate a random name in case none was provided\n    const name = Tools.getOption(options, 'name', `mesh_${Math.round(Math.random() * 1000000).toString()}`)\n    const focusOn = Tools.getOption(options, 'focusOn', true)\n    const color = Tools.getOption(options, 'color', 0xDDDDDD)\n    const opacity = Tools.getOption(options, 'opacity', 0.15)\n    const wireframe = Tools.getOption(options, 'wireframe', false)\n    const shininess = Tools.getOption(options, 'shininess', 300)\n    const doubleSide = Tools.getOption(options, 'doubleSide', false)\n\n    const loader = new STLLoader()\n    // loader.load( '../data/meshes/mask_smooth_simple.stl', function ( geometry ) {\n    loader.load(url, (geometry) => {\n      const material = new THREE.MeshPhongMaterial({\n        specular: 0xffffff,\n        shininess,\n        side: doubleSide ? THREE.DoubleSide : THREE.FrontSide,\n        color,\n        transparent: true,\n        opacity,\n        wireframe,\n      })\n\n      geometry.computeBoundingSphere()\n\n      const mesh = new THREE.Mesh(\n        geometry,\n        material,\n      )\n\n      that._scene.add(mesh)\n      that._meshCollection[name] = mesh\n\n      if (focusOn) that.focusOnMesh(name)\n\n      // call a callback if declared, with the name of the mesh in arg\n      const onDone = Tools.getOption(options, 'onDone', null)\n      if (onDone) {\n        onDone(name)\n        that._render()\n      }\n    })\n  }\n\n\n  /**\n   * @private\n   * deals with rendering and updating the controls\n   */\n  _animate() {\n    this._requestFrameId = requestAnimationFrame(this._animate.bind(this))\n    this._controls.update()\n  }\n\n  _render() {\n    this._renderer.render(this._scene, this._camera)\n  }\n\n\n  /**\n   * @private\n   * Throw a ray from the camera to the pointer, potentially intersect some sections.\n   * If so, emit the event `onRaycast` with the section instance as argument\n   */\n  _performRaycast() {\n    // update the picking ray with the camera and mouse position\n    this._raycaster.setFromCamera(this._raycastMouse, this._camera)\n\n    // calculate objects intersecting the picking ray\n    const intersects = this._raycaster.intersectObjects(this._scene.children, true)\n\n    if (intersects.length) {\n      // console.log(this._morphologyMeshCollection)\n      const sectionMesh = intersects[0].object\n\n      if ('sectionId' in sectionMesh.userData) {\n        const { sectionId } = sectionMesh.userData\n        const morphologyObj = sectionMesh.parent.getMorphology()\n        this.emit('onRaycast', [morphologyObj._sections[sectionId]])\n      } else {\n        this.emit('onRaycast', [null])\n      }\n    }\n  }\n\n\n  /**\n   * Add a MorphoPolyline object (which are ThreeJS Object3D) into the scene of this\n   * ThreeContext.\n   * @param {MorphoPolyline} morphoMesh - a MorphoPolyline instance\n   * @param {Object} options - the option object\n   * @param {String} options.name - the identifier to give to the MorphoPolyline instance within a local collection\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added morphology. If false, the camera will not change\n   * @param {Function} options.onDone - callback to be called when the morphology polyline is added. Called with the name of the morpho in argument\n   */\n  addMorphology(morphoMesh, options) {\n    // generate a random name in case none was provided\n    const name = options.name // set before\n    const focusOn = Tools.getOption(options, 'focusOn', true)\n    const focusDistance = Tools.getOption(options, 'distance', DEFAULT_FOCUS_DISTANCE)\n\n    this._morphologyMeshCollection[name] = morphoMesh\n    this._scene.add(morphoMesh)\n\n    if (focusOn) this.focusOnMorphology(name, focusDistance)\n\n    // call a callback if declared, with the name of the morphology in arg\n    const onDone = Tools.getOption(options, 'onDone')\n    if (onDone) {\n      onDone(name)\n    }\n\n    this._render()\n  }\n\n\n  /**\n   * Make the camera focus on a specific morphology\n   * @param {String|null} name - name of the morphology in the collection. If `null`, takes the first one\n   */\n  focusOnMorphology(name = null, distance = DEFAULT_FOCUS_DISTANCE) {\n    let morphoName = name\n    // if no name of morphology is provided, we take the first one\n    if (!morphoName) {\n      const allNames = Object.keys(this._morphologyMeshCollection)\n      if (allNames.length) {\n        morphoName = allNames[0]\n      } else {\n        return\n      }\n    }\n\n    const morpho = this._morphologyMeshCollection[morphoName]\n    const targetPoint = morpho.getTargetPoint()\n    // we try to get pretty close to the soma, hence the averageSide/5\n    this._camera.position.set(targetPoint.x, targetPoint.y, targetPoint.z - distance)\n    this._camera.lookAt(targetPoint)\n    this._controls.target.copy(targetPoint)\n    this._render()\n  }\n\n\n  /**\n   * Focus on a mesh, given its name\n   * @param {string} name - name of the mesh to focus on\n   */\n  focusOnMesh(name) {\n    const mesh = this._meshCollection[name]\n    const boundingSphere = mesh.geometry.boundingSphere\n\n    this._camera.position.set(boundingSphere.center.x - boundingSphere.radius * 3, boundingSphere.center.y, boundingSphere.center.z)\n    this._camera.lookAt(boundingSphere.center)\n    this._controls.target.copy(boundingSphere.center)\n    this._render()\n  }\n\n  /**\n   * Get the png image data as base64, in order to later, export as a file\n   */\n  getSnapshotData() {\n    const strMime = 'image/png'\n    // let strDownloadMime = \"image/octet-stream\"\n    const imgData = this._renderer.domElement.toDataURL(strMime)\n    // imgData.replace(strMime, strDownloadMime)\n    return imgData\n  }\n\n  /**\n   * Kills the scene, interaction, animation and reset all objects to null\n   */\n  destroy() {\n    this._controls.dispose()\n    cancelAnimationFrame(this._requestFrameId)\n    this._camera = null\n    this._controls = null\n    this._scene = null\n    this._morphologyMeshCollection = null\n    this._meshCollection = null\n    this._renderer.domElement.remove()\n    this._renderer = null\n  }\n}\n\nexport default ThreeContext\n","/*\n* @author Mugen87 / https://github.com/Mugen87\n*\n* Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n*\n*/\n\nimport * as THREE from 'three'\n\n\nconst Visible = 0\nconst Deleted = 1\n\nfunction QuickHull() {\n  this.tolerance = -1\n\n  this.faces = [] // the generated faces of the convex hull\n  this.newFaces = [] // this array holds the faces that are generated within a single iteration\n\n  // the vertex lists work as follows:\n  //\n  // let 'a' and 'b' be 'Face' instances\n  // let 'v' be points wrapped as instance of 'Vertex'\n  //\n  //     [v, v, ..., v, v, v, ...]\n  //      ^             ^\n  //      |             |\n  //  a.outside     b.outside\n  //\n  this.assigned = new VertexList()\n  this.unassigned = new VertexList()\n\n  this.vertices = [] // vertices of the hull (internal representation of given geometry data)\n}\n\nObject.assign(QuickHull.prototype, {\n\n  setFromPoints(points) {\n    if (Array.isArray(points) !== true) {\n      console.error('THREE.QuickHull: Points parameter is not an array.')\n    }\n\n    if (points.length < 4) {\n      console.error('THREE.QuickHull: The algorithm needs at least four points.')\n    }\n\n    this.makeEmpty()\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      this.vertices.push(new VertexNode(points[i]))\n    }\n\n    this.compute()\n\n    return this\n  },\n\n  setFromObject(object) {\n    const points = []\n\n    object.updateMatrixWorld(true)\n\n    object.traverse((node) => {\n      let i; let l; let\n        point\n\n      const geometry = node.geometry\n\n      if (geometry !== undefined) {\n        if (geometry.isGeometry) {\n          const vertices = geometry.vertices\n\n          for (i = 0, l = vertices.length; i < l; i++) {\n            point = vertices[i].clone()\n            point.applyMatrix4(node.matrixWorld)\n\n            points.push(point)\n          }\n        } else if (geometry.isBufferGeometry) {\n          const attribute = geometry.attributes.position\n\n          if (attribute !== undefined) {\n            for (i = 0, l = attribute.count; i < l; i++) {\n              point = new THREE.Vector3()\n\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld)\n\n              points.push(point)\n            }\n          }\n        }\n      }\n    })\n\n    return this.setFromPoints(points)\n  },\n\n  makeEmpty() {\n    this.faces = []\n    this.vertices = []\n\n    return this\n  },\n\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face\n\n    if (face.outside === null) {\n      this.assigned.append(vertex)\n    } else {\n      this.assigned.insertBefore(face.outside, vertex)\n    }\n\n    face.outside = vertex\n\n    return this\n  },\n\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n\n        face.outside = vertex.next\n      } else {\n        // vertex was the only outside vertex that face had\n\n        face.outside = null\n      }\n    }\n\n    this.assigned.remove(vertex)\n\n    return this\n  },\n\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n\n      const start = face.outside\n      let end = face.outside\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next\n      }\n\n      this.assigned.removeSubList(start, end)\n\n      // fix references\n\n      start.prev = end.next = null\n      face.outside = null\n\n      return start\n    }\n  },\n\n  // Removes all the visible vertices that 'face' is able to see\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face)\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n\n        this.unassigned.appendChain(faceVertices)\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n\n        let vertex = faceVertices\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n\n          const nextVertex = vertex.next\n\n          const distance = absorbingFace.distanceToPoint(vertex.point)\n\n          // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace)\n          } else {\n            this.unassigned.append(vertex)\n          }\n\n          // now assign next vertex\n\n          vertex = nextVertex\n        } while (vertex !== null)\n      }\n    }\n\n    return this\n  },\n\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first()\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n\n        const nextVertex = vertex.next\n\n        let maxDistance = this.tolerance\n\n        let maxFace = null\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i]\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point)\n\n            if (distance > maxDistance) {\n              maxDistance = distance\n              maxFace = face\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break\n          }\n        }\n\n        // 'maxFace' can be null e.g. if there are identical vertices\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n\n        vertex = nextVertex\n      } while (vertex !== null)\n    }\n\n    return this\n  },\n\n  // Computes the extremes of a simplex which will be the initial hull\n\n  computeExtremes() {\n    const min = new THREE.Vector3()\n    const max = new THREE.Vector3()\n\n    const minVertices = []\n    const maxVertices = []\n\n    let i; let l; let\n      j\n\n    // initially assume that the first vertex is the min/max\n\n    for (i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0]\n    }\n\n    min.copy(this.vertices[0].point)\n    max.copy(this.vertices[0].point)\n\n    // compute the min/max vertex on all six directions\n\n    for (i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i]\n      const point = vertex.point\n\n      // update the min coordinates\n\n      for (j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j))\n          minVertices[j] = vertex\n        }\n      }\n\n      // update the max coordinates\n\n      for (j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j))\n          maxVertices[j] = vertex\n        }\n      }\n    }\n\n    // use min/max vectors to compute an optimal epsilon\n\n    this.tolerance = 3 * Number.EPSILON * (\n      Math.max(Math.abs(min.x), Math.abs(max.x))\n      + Math.max(Math.abs(min.y), Math.abs(max.y))\n      + Math.max(Math.abs(min.z), Math.abs(max.z))\n    )\n\n    return { min: minVertices, max: maxVertices }\n  },\n\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n  computeInitialHull: (function () {\n    let line3; let plane; let\n      closestPoint\n\n    return function computeInitialHull() {\n      if (line3 === undefined) {\n        line3 = new THREE.Line3()\n        plane = new THREE.Plane()\n        closestPoint = new THREE.Vector3()\n      }\n\n      let vertex; const\n        vertices = this.vertices\n      const extremes = this.computeExtremes()\n      const min = extremes.min\n      const max = extremes.max\n\n      let v0; let v1; let v2; let\n        v3\n      let i; let l; let\n        j\n\n      // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n      // (max.x - min.x)\n      // (max.y - min.y)\n      // (max.z - min.z)\n\n      let distance; let\n        maxDistance = 0\n      let index = 0\n\n      for (i = 0; i < 3; i++) {\n        distance = max[i].point.getComponent(i) - min[i].point.getComponent(i)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          index = i\n        }\n      }\n\n      v0 = min[index]\n      v1 = max[index]\n\n      // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n      maxDistance = 0\n      line3.set(v0.point, v1.point)\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        vertex = vertices[i]\n\n        if (vertex !== v0 && vertex !== v1) {\n          line3.closestPointToPoint(vertex.point, true, closestPoint)\n\n          distance = closestPoint.distanceToSquared(vertex.point)\n\n          if (distance > maxDistance) {\n            maxDistance = distance\n            v2 = vertex\n          }\n        }\n      }\n\n      // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n      maxDistance = -1\n      plane.setFromCoplanarPoints(v0.point, v1.point, v2.point)\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        vertex = vertices[i]\n\n        if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n          distance = Math.abs(plane.distanceToPoint(vertex.point))\n\n          if (distance > maxDistance) {\n            maxDistance = distance\n            v3 = vertex\n          }\n        }\n      }\n\n      const faces = []\n\n      if (plane.distanceToPoint(v3.point) < 0) {\n        // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n        faces.push(\n          Face.create(v0, v1, v2),\n          Face.create(v3, v1, v0),\n          Face.create(v3, v2, v1),\n          Face.create(v3, v0, v2),\n        )\n\n        // set the twin edge\n\n        for (i = 0; i < 3; i++) {\n          j = (i + 1) % 3\n\n          // join face[ i ] i > 0, with the first face\n\n          faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j))\n\n          // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n          faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0))\n        }\n      } else {\n        // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n        faces.push(\n          Face.create(v0, v2, v1),\n          Face.create(v3, v0, v1),\n          Face.create(v3, v1, v2),\n          Face.create(v3, v2, v0),\n        )\n\n        // set the twin edge\n\n        for (i = 0; i < 3; i++) {\n          j = (i + 1) % 3\n\n          // join face[ i ] i > 0, with the first face\n\n          faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3))\n\n          // join face[ i ] with face[ i + 1 ]\n\n          faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1))\n        }\n      }\n\n      // the initial hull is the tetrahedron\n\n      for (i = 0; i < 4; i++) {\n        this.faces.push(faces[i])\n      }\n\n      // initial assignment of vertices to the faces of the tetrahedron\n\n      for (i = 0, l = vertices.length; i < l; i++) {\n        vertex = vertices[i]\n\n        if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n          maxDistance = this.tolerance\n          let maxFace = null\n\n          for (j = 0; j < 4; j++) {\n            distance = this.faces[j].distanceToPoint(vertex.point)\n\n            if (distance > maxDistance) {\n              maxDistance = distance\n              maxFace = this.faces[j]\n            }\n          }\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace)\n          }\n        }\n      }\n\n      return this\n    }\n  }()),\n\n  // Removes inactive faces\n\n  reindexFaces() {\n    const activeFaces = []\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      if (face.mark === Visible) {\n        activeFaces.push(face)\n      }\n    }\n\n    this.faces = activeFaces\n\n    return this\n  },\n\n  // Finds the next vertex to create faces with the current hull\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex; let\n        maxDistance = 0\n\n      // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face\n      let vertex = eyeFace.outside\n\n      // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          eyeVertex = vertex\n        }\n\n        vertex = vertex.next\n      } while (vertex !== null && vertex.face === eyeFace)\n\n      return eyeVertex\n    }\n  },\n\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n\n    this.deleteFaceVertices(face)\n\n    face.mark = Deleted\n\n    let edge\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0)\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n      edge = crossEdge.next\n    }\n\n    do {\n      const twinEdge = edge.twin\n      const oppositeFace = twinEdge.face\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon)\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n\n          horizon.push(edge)\n        }\n      }\n\n      edge = edge.next\n    } while (edge !== crossEdge)\n\n    return this\n  },\n\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head())\n\n    this.faces.push(face)\n\n    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin)\n\n    return face.getEdge(0) // the half edge whose vertex is the eyeVertex\n  },\n\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = []\n\n    let firstSideEdge = null\n    let previousSideEdge = null\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]\n\n      // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge)\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n        sideEdge.next.setTwin(previousSideEdge)\n      }\n\n      this.newFaces.push(sideEdge.face)\n      previousSideEdge = sideEdge\n    }\n\n    // perform final join of new faces\n\n    firstSideEdge.next.setTwin(previousSideEdge)\n\n    return this\n  },\n\n  // Adds a vertex to the hull\n\n  addVertexToHull(eyeVertex) {\n    const horizon = []\n\n    this.unassigned.clear()\n\n    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face)\n\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon)\n\n    this.addNewFaces(eyeVertex, horizon)\n\n    // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces)\n\n    return this\n  },\n\n  cleanup() {\n    this.assigned.clear()\n    this.unassigned.clear()\n    this.newFaces = []\n\n    return this\n  },\n\n  compute() {\n    let vertex\n\n    this.computeInitialHull()\n\n    // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex)\n    }\n\n    this.reindexFaces()\n\n    this.cleanup()\n\n    return this\n  },\n\n})\n\n//\n\nfunction Face() {\n  this.normal = new THREE.Vector3()\n  this.midpoint = new THREE.Vector3()\n  this.area = 0\n\n  this.constant = 0 // signed distance from face to the origin\n  this.outside = null // reference to a vertex in a vertex list this face can see\n  this.mark = Visible\n  this.edge = null\n}\n\nObject.assign(Face, {\n\n  create(a, b, c) {\n    const face = new Face()\n\n    const e0 = new HalfEdge(a, face)\n    const e1 = new HalfEdge(b, face)\n    const e2 = new HalfEdge(c, face)\n\n    // join edges\n\n    e0.next = e2.prev = e1\n    e1.next = e0.prev = e2\n    e2.next = e1.prev = e0\n\n    // main half edge reference\n\n    face.edge = e0\n\n    return face.compute()\n  },\n\n})\n\nObject.assign(Face.prototype, {\n\n  getEdge(i) {\n    let edge = this.edge\n\n    while (i > 0) {\n      edge = edge.next\n      i--\n    }\n\n    while (i < 0) {\n      edge = edge.prev\n      i++\n    }\n\n    return edge\n  },\n\n  compute: (function () {\n    let triangle\n\n    return function compute() {\n      if (triangle === undefined) triangle = new THREE.Triangle()\n\n      const a = this.edge.tail()\n      const b = this.edge.head()\n      const c = this.edge.next.head()\n\n      triangle.set(a.point, b.point, c.point)\n\n      triangle.getNormal(this.normal)\n      triangle.getMidpoint(this.midpoint)\n      this.area = triangle.getArea()\n\n      this.constant = this.normal.dot(this.midpoint)\n\n      return this\n    }\n  }()),\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant\n  },\n\n})\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nfunction HalfEdge(vertex, face) {\n  this.vertex = vertex\n  this.prev = null\n  this.next = null\n  this.twin = null\n  this.face = face\n}\n\nObject.assign(HalfEdge.prototype, {\n\n  head() {\n    return this.vertex\n  },\n\n  tail() {\n    return this.prev ? this.prev.vertex : null\n  },\n\n  length() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point)\n    }\n\n    return -1\n  },\n\n  lengthSquared() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point)\n    }\n\n    return -1\n  },\n\n  setTwin(edge) {\n    this.twin = edge\n    edge.twin = this\n\n    return this\n  },\n\n})\n\n// A vertex as a double linked list node.\n\nfunction VertexNode(point) {\n  this.point = point\n  this.prev = null\n  this.next = null\n  this.face = null // the face that is able to see this vertex\n}\n\n// A double linked list that contains vertex nodes.\n\nfunction VertexList() {\n  this.head = null\n  this.tail = null\n}\n\nObject.assign(VertexList.prototype, {\n\n  first() {\n    return this.head\n  },\n\n  last() {\n    return this.tail\n  },\n\n  clear() {\n    this.head = this.tail = null\n\n    return this\n  },\n\n  // Inserts a vertex before the target vertex\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev\n    vertex.next = target\n\n    if (vertex.prev === null) {\n      this.head = vertex\n    } else {\n      vertex.prev.next = vertex\n    }\n\n    target.prev = vertex\n\n    return this\n  },\n\n  // Inserts a vertex after the target vertex\n\n  insertAfter(target, vertex) {\n    vertex.prev = target\n    vertex.next = target.next\n\n    if (vertex.next === null) {\n      this.tail = vertex\n    } else {\n      vertex.next.prev = vertex\n    }\n\n    target.next = vertex\n\n    return this\n  },\n\n  // Appends a vertex to the end of the linked list\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n    vertex.next = null // the tail has no subsequent vertex\n\n    this.tail = vertex\n\n    return this\n  },\n\n  // Appends a chain of vertices where 'vertex' is the head.\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n\n    // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next\n    }\n\n    this.tail = vertex\n\n    return this\n  },\n\n  // Removes a vertex from the linked list\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next\n    } else {\n      vertex.prev.next = vertex.next\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev\n    } else {\n      vertex.next.prev = vertex.prev\n    }\n\n    return this\n  },\n\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next\n    } else {\n      a.prev.next = b.next\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev\n    } else {\n      b.next.prev = a.prev\n    }\n\n    return this\n  },\n\n  isEmpty() {\n    return this.head === null\n  },\n\n})\n\n\nexport default QuickHull\n","/*\n* @author Mugen87 / https://github.com/Mugen87\n*/\n\nimport * as THREE from 'three'\nimport QuickHull from './QuickHull'\n\n\n// ConvexGeometry\n\nfunction ConvexGeometry(points) {\n  THREE.Geometry.call(this)\n\n  this.fromBufferGeometry(new ConvexBufferGeometry(points))\n  this.mergeVertices()\n}\n\nConvexGeometry.prototype = Object.create(THREE.Geometry.prototype)\nConvexGeometry.prototype.constructor = ConvexGeometry\n\n// ConvexBufferGeometry\n\nfunction ConvexBufferGeometry(points) {\n  THREE.BufferGeometry.call(this)\n\n  // buffers\n\n  const vertices = []\n  const normals = []\n\n  // execute QuickHull\n\n  if (QuickHull === undefined) {\n    console.error('THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on THREE.QuickHull')\n  }\n\n  const quickHull = new QuickHull().setFromPoints(points)\n\n  // generate vertices and normals\n\n  const faces = quickHull.faces\n\n  for (let i = 0; i < faces.length; i++) {\n    const face = faces[i]\n    let edge = face.edge\n\n    // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n    do {\n      const point = edge.head().point\n\n      vertices.push(point.x, point.y, point.z)\n      normals.push(face.normal.x, face.normal.y, face.normal.z)\n\n      edge = edge.next\n    } while (edge !== face.edge)\n  }\n\n  // build geometry\n\n  this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n  this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3))\n}\n\nConvexBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype)\nConvexBufferGeometry.prototype.constructor = ConvexBufferGeometry\n\n// export\n\nexport default ({\n  ConvexGeometry,\n  ConvexBufferGeometry,\n})\n","import * as THREE from 'three'\nimport Tools from './Tools'\nimport ConvexGeometry from './thirdparty/ConvexGeometry'\n\n\n/**\n * This is the base class for `MorphologyPolyline` and `MorphologyPolycylinder`.\n * It handles the common features, mainly related to soma creation\n */\nclass MorphologyShapeBase extends THREE.Object3D {\n  /**\n   * @constructor\n   * Builds a moprho as a polyline\n   * @param {Object} morpho - raw object that describes a morphology (usually straight from a JSON file)\n   * @param {object} options - the option object\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   */\n  constructor(morpho, options) {\n    super()\n\n    this.userData.morphologyName = options.name\n    this._pointToTarget = null\n    this._morpho = morpho\n\n    // fetch the optional color\n    const color = Tools.getOption(options, 'color', null)\n\n    // simple color lookup, so that every section type is shown in a different color\n    this._sectionColors = {\n      axon: color || 0x1111ff,\n      basal_dendrite: color || 0xff1111,\n      apical_dendrite: color || 0xf442ad,\n    }\n  }\n\n\n  /**\n   * @private\n   * The method to build a soma mesh using the 'default' way, aka using simply the\n   * data from the soma.\n   * @return {THREE.Mesh} the soma mesh\n   */\n  _buildSomaDefault() {\n    const soma = this._morpho.getSoma()\n    const somaPoints = soma.getPoints()\n\n    // case when soma is a single point\n    if (somaPoints.length === 1) {\n      const somaSphere = new THREE.Mesh(\n        new THREE.SphereGeometry(soma.getRadius(), 32, 32),\n        new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }),\n      )\n\n      somaSphere.position.set(somaPoints[0][0], somaPoints[0][1], somaPoints[0][2])\n      return somaSphere\n\n    // this is a 3-point soma, probably colinear\n    } if (somaPoints.length === 3) {\n      /*\n      let radius = soma.getRadius()\n      let mat = new THREE.MeshPhongMaterial( {color: 0x000000, transparent: true, opacity:0.3} )\n\n      let c1 = Tools.makeCylinder(\n        new THREE.Vector3(...somaPoints[0]),\n        new THREE.Vector3(...somaPoints[1]),\n        radius,\n        radius,\n        false,\n        mat\n      )\n\n      let c2 = Tools.makeCylinder(\n        new THREE.Vector3(...somaPoints[1]),\n        new THREE.Vector3(...somaPoints[2]),\n        radius,\n        radius,\n        false,\n        mat\n      )\n\n      let somaCyl = new THREE.Object3D()\n      somaCyl.add(c1)\n      somaCyl.add(c2)\n      return somaCyl\n      */\n\n      const somaSphere = new THREE.Mesh(\n        new THREE.SphereGeometry(soma.getRadius(), 32, 32),\n        new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }),\n      )\n\n      somaSphere.position.set(somaPoints[0][0], somaPoints[0][1], somaPoints[0][2])\n      return somaSphere\n\n\n    // when soma is multiple points\n    } if (somaPoints.length > 1) {\n      // compute the average of the points\n      const center = soma.getCenter()\n      const centerV = new THREE.Vector3(center[0], center[1], center[2])\n      const geometry = new THREE.Geometry()\n\n      for (let i = 0; i < somaPoints.length; i += 1) {\n        geometry.vertices.push(\n          new THREE.Vector3(somaPoints[i][0], somaPoints[i][1], somaPoints[i][2]),\n          new THREE.Vector3(\n            somaPoints[(i + 1) % somaPoints.length][0],\n            somaPoints[(i + 1) % somaPoints.length][1],\n            somaPoints[(i + 1) % somaPoints.length][2],\n          ),\n          centerV,\n        )\n        geometry.faces.push(new THREE.Face3(3 * i, 3 * i + 1, 3 * i + 2))\n      }\n\n      const somaMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({\n        color: 0x000000,\n        transparent: true,\n        opacity: 0.3,\n        side: THREE.DoubleSide,\n      }))\n      return somaMesh\n    }\n    console.warn('No soma defined')\n    return null\n  }\n\n\n  /**\n   * @private\n   * Here we build a soma convex polygon based on the 1st points of the orphan\n   * sections + the points available in the soma description\n   * @return {THREE.Mesh} the soma mesh\n   */\n  _buildSomaFromOrphanSections() {\n    const somaPoints = this._morpho.getSoma().getPoints()\n    let somaMesh = null\n\n    try {\n      // getting all the 1st points of orphan sections\n      const somaPolygonPoints = this._morpho.getOrphanSections().map((s) => {\n        const allPoints = s.getPoints()\n        const firstOne = allPoints[1]\n        return new THREE.Vector3(...firstOne)\n      })\n\n      // adding the points of the soma (adds values mostly if we a soma polygon)\n      for (let i = 0; i < somaPoints.length; i += 1) {\n        somaPolygonPoints.push(new THREE.Vector3(...somaPoints[i]))\n      }\n\n      const geometry = new ConvexGeometry(somaPolygonPoints)\n      const material = new THREE.MeshPhongMaterial({\n        color: 0x555555,\n        transparent: true,\n        opacity: 0.7,\n        side: THREE.DoubleSide,\n      })\n      somaMesh = new THREE.Mesh(geometry, material)\n      return somaMesh\n    } catch (e) {\n      console.warn('Attempted to build a soma from orphan section points but failed. Back to the regular version.')\n      return this._buildSomaDefault()\n    }\n  }\n\n\n  /**\n   * @private\n   * Builds the soma. The type of soma depends on the option\n   * @param {Object} options - The option object\n   * @param {String|null} options.somaMode - \"default\" to display only the soma data or \"fromOrphanSections\" to build a soma using the orphan sections\n   */\n  _buildSoma(options) {\n    this._pointToTarget = this._morpho.getSoma().getCenter()\n    // can be 'default' or 'fromOrphanSections'\n    const buildMode = Tools.getOption(options, 'somaMode', null)\n    let somaMesh = null\n\n    if (buildMode === 'fromOrphanSections') {\n      somaMesh = this._buildSomaFromOrphanSections()\n    } else {\n      somaMesh = this._buildSomaDefault()\n    }\n\n    return somaMesh\n  }\n\n\n  /**\n   * Get the point to target when using the method lookAt. If the soma is valid,\n   * this will be the center of the soma. If no soma is valid, it will be the\n   * center of the box\n   * @return {Array} center with the shape [x: Number, y: Number, z: Number]\n   */\n  getTargetPoint() {\n    if (this._pointToTarget) {\n      // rotate this because Allen needs it (just like the sections)\n      const lookat = new THREE.Vector3(this._pointToTarget[0], this._pointToTarget[1], this._pointToTarget[2])\n      lookat.applyAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI)\n      lookat.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI)\n      return lookat\n    }\n    const center = new THREE.Vector3()\n    this.box.getCenter(center)\n    return center\n  }\n\n\n  /**\n   * Get the morphology object tied to _this_ mesh\n   * @return {morphologycorejs.Morphology}\n   */\n  getMorphology() {\n    return this._morpho\n  }\n}\n\n\nexport default MorphologyShapeBase\n","import * as THREE from 'three'\nimport MorphologyShapeBase from './MorphologyShapeBase'\n\n/**\n * The MorphologyPolyline is the simplest 3D representation of a morphology, using\n * simple polylines.\n * Compared to its cylinder-based alternative (MorphologyPolycylinder), this one\n * is more suitable for displaying several morphologies (up to maybe a hundred,\n * depending on length and machine performance)\n * MorphologyPolyline extends from THREE.Object so that it's easy to integrate.\n * It's constructor\n */\nclass MorphologyPolyline extends MorphologyShapeBase {\n  /**\n   * @constructor\n   * Builds a moprho as a polyline\n   * @param {Morphology} morpho - raw object that describes a morphology (usually straight from a JSON file)\n   * @param {object} options - the option object\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   */\n  constructor(morpho, options) {\n    super(morpho, options)\n    const sections = this._morpho.getArrayOfSections()\n\n    // creating a polyline for each section\n    for (let i = 0; i < sections.length; i += 1) {\n      const sectionPolyline = this._buildSection(sections[i])\n      this.add(sectionPolyline)\n    }\n\n    // adding the soma mesh, but sometimes, there is no soma\n    const somaData = this._morpho.getSoma()\n    if (somaData) {\n      const somaShape = this._buildSoma(options)\n      this.add(somaShape)\n    }\n\n    // this is because the Allen ref is not oriented the same way as WebGL\n    this.rotateX(Math.PI)\n    this.rotateY(Math.PI)\n\n    // compute the bounding box, useful for further camera targeting\n    this.box = new THREE.Box3().setFromObject(this)\n  }\n\n\n  /**\n   * @private\n   * Builds a single section from a raw segment description and returns it.\n   * A section is usually composed of multiple segments\n   * @param {Section} section - sub part of the morpho raw object thar deals with a single section\n   * @return {THREE.Line} the constructed polyline\n   */\n  _buildSection(section) {\n    const material = new THREE.LineBasicMaterial({\n      color: this._sectionColors[section.getTypename()],\n    })\n\n    const sectionPoints = section.getPoints()\n    const geometry = new THREE.Geometry()\n\n    for (let i = 0; i < sectionPoints.length; i += 1) {\n      geometry.vertices.push(new THREE.Vector3(\n        sectionPoints[i][0], // x\n        sectionPoints[i][1], // y\n        sectionPoints[i][2], // z\n      ))\n    }\n\n    const line = new THREE.Line(geometry, material)\n\n    // adding some metadata as it can be useful for raycasting\n    line.name = section.getId()\n    line.userData.sectionId = section.getId()\n    line.userData.typevalue = section.getTypevalue()\n    line.userData.typename = section.getTypename()\n\n    return line\n  }\n}\n\n\nexport default MorphologyPolyline\n","/*\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport * as THREE from 'three'\n\nconst BufferGeometryUtils = {\n\n  computeTangents(geometry) {\n    const index = geometry.index\n    const attributes = geometry.attributes\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null\n       || attributes.position === undefined\n       || attributes.normal === undefined\n       || attributes.uv === undefined) {\n      console.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()')\n      return\n    }\n\n    const indices = index.array\n    const positions = attributes.position.array\n    const normals = attributes.normal.array\n    const uvs = attributes.uv.array\n\n    const nVertices = positions.length / 3\n\n    if (attributes.tangent === undefined) {\n      geometry.addAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4))\n    }\n\n    const tangents = attributes.tangent.array\n\n    const tan1 = []; const\n      tan2 = []\n\n    for (var i = 0; i < nVertices; i++) {\n      tan1[i] = new THREE.Vector3()\n      tan2[i] = new THREE.Vector3()\n    }\n\n    const vA = new THREE.Vector3()\n\n\n    const vB = new THREE.Vector3()\n\n\n    const vC = new THREE.Vector3()\n\n\n    const uvA = new THREE.Vector2()\n\n\n    const uvB = new THREE.Vector2()\n\n\n    const uvC = new THREE.Vector2()\n\n\n    const sdir = new THREE.Vector3()\n\n\n    const tdir = new THREE.Vector3()\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3)\n      vB.fromArray(positions, b * 3)\n      vC.fromArray(positions, c * 3)\n\n      uvA.fromArray(uvs, a * 2)\n      uvB.fromArray(uvs, b * 2)\n      uvC.fromArray(uvs, c * 2)\n\n      const x1 = vB.x - vA.x\n      const x2 = vC.x - vA.x\n\n      const y1 = vB.y - vA.y\n      const y2 = vC.y - vA.y\n\n      const z1 = vB.z - vA.z\n      const z2 = vC.z - vA.z\n\n      const s1 = uvB.x - uvA.x\n      const s2 = uvC.x - uvA.x\n\n      const t1 = uvB.y - uvA.y\n      const t2 = uvC.y - uvA.y\n\n      const r = 1.0 / (s1 * t2 - s2 * t1)\n\n      sdir.set(\n        (t2 * x1 - t1 * x2) * r,\n        (t2 * y1 - t1 * y2) * r,\n        (t2 * z1 - t1 * z2) * r,\n      )\n\n      tdir.set(\n        (s1 * x2 - s2 * x1) * r,\n        (s1 * y2 - s2 * y1) * r,\n        (s1 * z2 - s2 * z1) * r,\n      )\n\n      tan1[a].add(sdir)\n      tan1[b].add(sdir)\n      tan1[c].add(sdir)\n\n      tan2[a].add(tdir)\n      tan2[b].add(tdir)\n      tan2[c].add(tdir)\n    }\n\n    let groups = geometry.groups\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length,\n      }]\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i]\n\n      var start = group.start\n      var count = group.count\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(\n          indices[j + 0],\n          indices[j + 1],\n          indices[j + 2],\n        )\n      }\n    }\n\n    const tmp = new THREE.Vector3(); const\n      tmp2 = new THREE.Vector3()\n    const n = new THREE.Vector3(); const\n      n2 = new THREE.Vector3()\n    let w; let t; let\n      test\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3)\n      n2.copy(n)\n\n      t = tan1[v]\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t)\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize()\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t)\n      test = tmp2.dot(tan2[v])\n      w = (test < 0.0) ? -1.0 : 1.0\n\n      tangents[v * 4] = tmp.x\n      tangents[v * 4 + 1] = tmp.y\n      tangents[v * 4 + 2] = tmp.z\n      tangents[v * 4 + 3] = w\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i]\n\n      var start = group.start\n      var count = group.count\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0])\n        handleVertex(indices[j + 1])\n        handleVertex(indices[j + 2])\n      }\n    }\n  },\n\n  /**\n   * @param  {Array<THREE.BufferGeometry>} geometries\n   * @return {THREE.BufferGeometry}\n   */\n  mergeBufferGeometries(geometries, useGroups) {\n    const isIndexed = geometries[0].index !== null\n\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n    const attributes = {}\n    const morphAttributes = {}\n\n    const mergedGeometry = new THREE.BufferGeometry()\n\n    let offset = 0\n\n    for (var i = 0; i < geometries.length; ++i) {\n      const geometry = geometries[i]\n\n      // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) return null\n\n      // gather attributes, exit early if they're different\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) return null\n\n        if (attributes[name] === undefined) attributes[name] = []\n\n        attributes[name].push(geometry.attributes[name])\n      }\n\n      // gather morph attributes, exit early if they're different\n\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) return null\n\n        if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n        morphAttributes[name].push(geometry.morphAttributes[name])\n      }\n\n      // gather .userData\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n      mergedGeometry.userData.mergedUserData.push(geometry.userData)\n\n      if (useGroups) {\n        var count\n\n        if (isIndexed) {\n          count = geometry.index.count\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count\n        } else {\n          return null\n        }\n\n        mergedGeometry.addGroup(offset, count, i)\n\n        offset += count\n      }\n    }\n\n    // merge indices\n\n    if (isIndexed) {\n      let indexOffset = 0\n      const mergedIndex = []\n\n      for (var i = 0; i < geometries.length; ++i) {\n        const index = geometries[i].index\n\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset)\n        }\n\n        indexOffset += geometries[i].attributes.position.count\n      }\n\n      mergedGeometry.setIndex(mergedIndex)\n    }\n\n    // merge attributes\n\n    for (var name in attributes) {\n      const mergedAttribute = this.mergeBufferAttributes(attributes[name])\n\n      if (!mergedAttribute) return null\n\n      mergedGeometry.addAttribute(name, mergedAttribute)\n    }\n\n    // merge morph attributes\n\n    for (var name in morphAttributes) {\n      const numMorphTargets = morphAttributes[name][0].length\n\n      if (numMorphTargets === 0) break\n\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n      mergedGeometry.morphAttributes[name] = []\n\n      for (var i = 0; i < numMorphTargets; ++i) {\n        const morphAttributesToMerge = []\n\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i])\n        }\n\n        const mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge)\n\n        if (!mergedMorphAttribute) return null\n\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n      }\n    }\n\n    return mergedGeometry\n  },\n\n  /**\n   * @param {Array<THREE.BufferAttribute>} attributes\n   * @return {THREE.BufferAttribute}\n   */\n  mergeBufferAttributes(attributes) {\n    let TypedArray\n    let itemSize\n    let normalized\n    let arrayLength = 0\n\n    for (var i = 0; i < attributes.length; ++i) {\n      const attribute = attributes[i]\n\n      if (attribute.isInterleavedBufferAttribute) return null\n\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor\n      if (TypedArray !== attribute.array.constructor) return null\n\n      if (itemSize === undefined) itemSize = attribute.itemSize\n      if (itemSize !== attribute.itemSize) return null\n\n      if (normalized === undefined) normalized = attribute.normalized\n      if (normalized !== attribute.normalized) return null\n\n      arrayLength += attribute.array.length\n    }\n\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset)\n\n      offset += attributes[i].array.length\n    }\n\n    return new THREE.BufferAttribute(array, itemSize, normalized)\n  },\n\n}\n\n\nexport default BufferGeometryUtils\n","import * as THREE from 'three'\nimport Tools from './Tools'\nimport MorphologyShapeBase from './MorphologyShapeBase'\nimport BufferGeometryUtils from './thirdparty/BufferGeometryUtils'\n\n\n/**\n * The MorphologyPolycylinder is a tubular representation of a morphology, using cylinders.\n * this alternative to MorphologyPolyline is heavier on CPU and GPU so is more made when\n * displaying a small number of morphologies.\n * MorphologyPolycylinder extends from THREE.Object so that it's easy to integrate.\n * It's constructor\n */\nclass MorphologyPolycylinder extends MorphologyShapeBase {\n  /**\n   * @constructor\n   * Builds a moprho as a polyline\n   * @param {Object} morpho - raw object that describes a morphology (usually straight from a JSON file)\n   * @param {object} options - the option object\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   */\n  constructor(morpho, options) {\n    super(morpho, options)\n\n    this._sectionTubeMaterials = {\n      axon: new THREE.MeshPhongMaterial({ color: this._sectionColors.axon }),\n      basal_dendrite: new THREE.MeshPhongMaterial({ color: this._sectionColors.basal_dendrite }),\n      apical_dendrite: new THREE.MeshPhongMaterial({ color: this._sectionColors.apical_dendrite }),\n    }\n\n    const sections = this._morpho.getArrayOfSections()\n\n    // creating a polyline for each section\n    for (let i = 0; i < sections.length; i += 1) {\n      const section = this._buildSection(sections[i])\n      if (section) this.add(section)\n    }\n\n    // adding the soma, but sometimes, there is no soma data...\n    const somaData = this._morpho.getSoma()\n    if (somaData) {\n      const somaShape = this._buildSoma(options)\n      this.add(somaShape)\n    }\n\n    // this is because the Allen ref is not oriented the same way as WebGL\n    this.rotateX(Math.PI)\n    this.rotateY(Math.PI)\n\n    // compute the bounding box, useful for further camera targeting\n    this.box = new THREE.Box3().setFromObject(this)\n  }\n\n\n  /**\n   * @private\n   * Builds a single section from a raw segment description and returns it.\n   * A section is usually composed of multiple segments\n   * @param {Section} sectionDescription - sub part of the morpho raw object thar deals with a single section\n   * @return {THREE.Line} the constructed polyline\n   */\n  _buildSection(section) {\n    const material = this._sectionTubeMaterials[section.getTypename()]\n    const sectionPoints = section.getPoints()\n    const sectionRadius = section.getRadiuses()\n    const startIndex = section.getParent() ? 0 : 1\n\n    if ((sectionPoints.length - startIndex) < 2) return null\n\n    const arrayOfGeom = []\n\n    for (let i = startIndex; i < sectionPoints.length - 1; i += 1) {\n      const cyl = Tools.makeCylinder(\n        new THREE.Vector3( // vStart\n          sectionPoints[i][0],\n          sectionPoints[i][1],\n          sectionPoints[i][2],\n        ),\n        new THREE.Vector3( // vEnd\n          sectionPoints[i + 1][0],\n          sectionPoints[i + 1][1],\n          sectionPoints[i + 1][2],\n        ),\n        sectionRadius[i], // rStart\n        sectionRadius[i + 1], // rEnd\n        false, // openEnd\n      )\n      arrayOfGeom.push(cyl)\n    }\n\n    // merging the buffer geometries to make things faster\n    const sectionGeom = BufferGeometryUtils.mergeBufferGeometries(arrayOfGeom)\n    const sectionMesh = new THREE.Mesh(sectionGeom, material)\n\n    // adding some metadata as it can be useful for raycasting\n    sectionMesh.name = section.getId()\n    sectionMesh.userData.sectionId = section.getId()\n    sectionMesh.userData.typevalue = section.getTypevalue()\n    sectionMesh.userData.typename = section.getTypename()\n\n    return sectionMesh\n  }\n}\n\nexport default MorphologyPolycylinder\n","import morphologycorejs from 'morphologycorejs'\nimport ThreeContext from './ThreeContext'\nimport MorphologyPolyline from './MorphologyPolyline'\nimport MorphologyPolycylinder from './MorphologyPolycylinder'\nimport Tools from './Tools'\n\n\n/**\n* The MorphoViewer class is the entry point object of the MorphoViewer project\n* and is the only object the user should be dealing with.\n*/\nclass MorphoViewer {\n  constructor(divObj = null) {\n    if (!divObj) {\n      console.error('MorphoViewer needs a div object to display WebGL context.')\n      return\n    }\n\n    this._threeContext = new ThreeContext(divObj)\n  }\n\n\n  /**\n   * Add a morphology to the collection so that it displays.\n   * @param {Object|morphologycorejs.Morphology} morphoObj - describes the morphology of a neuron.\n   * This data comes straight from the JSON file or it can also be a Morphology object from `morphologycorejs`\n   * @param {object} options - the optional values\n   * @param {String} options.name - The name to give to this morphology. Will be used as an identifier for several operations\n   * @param {Boolean} options.asPolyline - if true: shows a polyline view. false: shows a tubular view (default: true)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added morphology. If false, the camera will not change\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   * @param {String} options.somaMode - \"default\" to display only the soma data or \"fromOrphanSections\" to build a soma using the orphan sections\n   * @param {Function} options.onDone - callback when the morphology is displayed. Called with the name (given or generated) of the morphology\n   * @param {Number} options.distance - the distance between the camera and the soma. Only relevant if `onFocus` is `true`\n   */\n  addMorphology(morphoObj, options) {\n    // create a morphology object from the raw object\n    let morphology = null\n\n    // creates an auto name if none is giver\n    options.name = Tools.getOption(options, 'name', `morpho_${Math.round(Math.random() * 1000000).toString()}`)\n\n    if (morphoObj instanceof morphologycorejs.Morphology) {\n      morphology = morphoObj\n    } else {\n      morphology = new morphologycorejs.Morphology()\n      morphology.buildFromRawMorphology(morphoObj)\n    }\n\n    morphology.setId(options.name)\n\n    const asPolyline = Tools.getOption(options, 'asPolyline', true)\n\n    if (asPolyline) {\n      const morphoPolyLine = new MorphologyPolyline(morphology, options)\n      this._threeContext.addMorphology(morphoPolyLine, options)\n    } else {\n      const morpho = new MorphologyPolycylinder(morphology, options)\n      this._threeContext.addMorphology(morpho, options)\n    }\n  }\n\n\n  /**\n   * Adds a mesh from its URL. The mesh has to encoded into the STL format\n   * @param {String} url - the url of the STL file\n   * @param {Object} options - the options object\n   * @param {String} options.name - optional name of this mesh (useful for further operations such as centering the view)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added mesh. If false, the camera will not change\n   */\n  addStlToMeshCollection(url, options) {\n    this._threeContext.addStlToMeshCollection(url, options)\n  }\n\n\n  /**\n   * Kill all to save up memory, stop the annimation, removes events, delete the canvas\n   */\n  destroy() {\n    this._threeContext.destroy()\n  }\n\n\n  /**\n   * Get the field of view angle of the camera, in degrees\n   * @return {Number}\n   */\n  getCameraFieldOfView() {\n    return this._threeContext.getCameraFieldOfView()\n  }\n\n\n  /**\n   * Define the camera field of view, in degrees\n   * @param {Number} fov - the fov\n   */\n  setCameraFieldOfView(fov) {\n    this._threeContext.setCameraFieldOfView(fov)\n  }\n\n\n  /**\n   * Make the camera look at the soma of a morphology (or the center of it's bounding box\n   * if the neuron does not have soma data)\n   * @param {String} name - the name of the neuron to focus on\n   * @param {Number} distance - distance from the soma center (in world space, most likely microns)\n   */\n  focusOnMorphology(name, distance) {\n    this._threeContext.focusOnMorphology(name, distance)\n  }\n\n\n  /**\n   * Make the camera focus on the given mesh\n   * @param {String} name - name of the mesh\n   */\n  focusOnMesh(name) {\n    this._threeContext.focusOnMesh(name)\n  }\n\n\n  /**\n   * Define a callback associated with clicking on a section. The callback function\n   * is called with the `morphologycorejs.Section` instance as arguments (or `undefined`)\n   */\n  onRaycast(cb) {\n    this._threeContext.on('onRaycast', cb)\n  }\n\n\n  /**\n   *\n   */\n  takeScreenshot(filename = 'capture.png') {\n    const imageData = this._threeContext.getSnapshotData()\n    Tools.triggerDownload(imageData, filename)\n  }\n}\n\nexport default MorphoViewer\n","import MorphoViewer from './MorphoViewer'\n\nexport default ({\n  MorphoViewer,\n})\n"],"names":["THREE.Vector3","THREE.Vector2","THREE.Quaternion","THREE.EventDispatcher","THREE.DefaultLoadingManager","THREE.FileLoader","THREE.BufferGeometry","THREE.BufferAttribute","THREE.Float32BufferAttribute","THREE.LoaderUtils","THREE.Matrix4","THREE.CylinderBufferGeometry","THREE.PerspectiveCamera","THREE.Scene","THREE.AmbientLight","THREE.DirectionalLight","THREE.WebGLRenderer","THREE.Raycaster","THREE.MeshPhongMaterial","THREE.DoubleSide","THREE.FrontSide","THREE.Mesh","THREE.Line3","THREE.Plane","THREE.Triangle","THREE.Geometry","THREE.Object3D","THREE.SphereGeometry","THREE.Face3","THREE.MeshBasicMaterial","ConvexGeometry","THREE.Box3","THREE.LineBasicMaterial","THREE.Line"],"mappings":"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"}