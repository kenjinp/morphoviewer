{"version":3,"file":"morphoviewer.js","sources":["../src/thirdparty/STLLoader.js","../src/Tools.js","../src/EventManager.js","../src/ThreeContext.js","../src/thirdparty/QuickHull.js","../src/thirdparty/ConvexGeometry.js","../src/MorphologyShapeBase.js","../src/MorphologyPolyline.js","../src/thirdparty/BufferGeometryUtils.js","../src/MorphologyPolycylinder.js","../src/MorphoViewer.js","../src/main.js"],"sourcesContent":["/*\n * @author aleeper / http://adamleeper.com/\n * @author mrdoob / http://mrdoob.com/\n * @author gero3 / https://github.com/gero3\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Description: A THREE loader for STL ASCII files, as created by Solidworks and other CAD programs.\n *\n * Supports both binary and ASCII encoded files, with automatic detection of type.\n *\n * The loader returns a non-indexed buffer geometry.\n *\n * Limitations:\n *  Binary decoding supports \"Magics\" color format (http://en.wikipedia.org/wiki/STL_(file_format)#Color_in_binary_STL).\n *  There is perhaps some question as to how valid it is to always assume little-endian-ness.\n *  ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *  var loader = new THREE.STLLoader();\n *  loader.load( './models/stl/slotted_disk.stl', function ( geometry ) {\n *    scene.add( new THREE.Mesh( geometry ) );\n *  });\n *\n * For binary STLs geometry might contain colors for vertices. To use it:\n *  // use the same code to load STL as above\n *  if (geometry.hasColors) {\n *    material = new THREE.MeshPhongMaterial({ opacity: geometry.alpha, vertexColors: THREE.VertexColors });\n *  } else { .... }\n *  var mesh = new THREE.Mesh( geometry, material );\n */\n\nimport pako from 'pako'\nimport * as THREE from 'three'\n\n\nconst STLLoader = function (manager) {\n  this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager\n}\n\nSTLLoader.prototype = {\n\n  constructor: STLLoader,\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this\n\n    const loader = new THREE.FileLoader(scope.manager)\n    loader.setResponseType('arraybuffer')\n    loader.load(url, (buf) => {\n      // trying to un-gzip it with Pako\n      try {\n        buf = pako.inflate(buf).buffer\n      } catch (err) {\n      }\n\n      try {\n        onLoad(scope.parse(buf))\n      } catch (exception) {\n        if (onError) {\n          onError(exception)\n        }\n      }\n    }, onProgress, onError)\n  },\n\n  parse(data) {\n    function isBinary(data) {\n      let expect; let face_size; let n_faces; let\n        reader\n      reader = new DataView(data)\n      face_size = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8)\n      n_faces = reader.getUint32(80, true)\n      expect = 80 + (32 / 8) + (n_faces * face_size)\n\n      if (expect === reader.byteLength) {\n        return true\n      }\n\n      // An ASCII STL data must begin with 'solid ' as the first six bytes.\n      // However, ASCII STLs lacking the SPACE after the 'd' are known to be\n      // plentiful.  So, check the first 5 bytes for 'solid'.\n\n      // Several encodings, such as UTF-8, precede the text with up to 5 bytes:\n      // https://en.wikipedia.org/wiki/Byte_order_mark#Byte_order_marks_by_encoding\n      // Search for \"solid\" to start anywhere after those prefixes.\n\n      // US-ASCII ordinal values for 's', 'o', 'l', 'i', 'd'\n\n      const solid = [115, 111, 108, 105, 100]\n\n      for (let off = 0; off < 5; off++) {\n        // If \"solid\" text is matched to the current offset, declare it to be an ASCII STL.\n\n        if (matchDataViewAt(solid, reader, off)) return false\n      }\n\n      // Couldn't find \"solid\" text at the beginning; it is binary STL.\n\n      return true\n    }\n\n    function matchDataViewAt(query, reader, offset) {\n      // Check if each byte in query matches the corresponding byte from the current offset\n\n      for (let i = 0, il = query.length; i < il; i++) {\n        if (query[i] !== reader.getUint8(offset + i, false)) return false\n      }\n\n      return true\n    }\n\n    function parseBinary(data) {\n      const reader = new DataView(data)\n      const faces = reader.getUint32(80, true)\n\n      let r; let g; let b; let hasColors = false; let\n        colors\n      let defaultR; let defaultG; let defaultB; let\n        alpha\n\n      // process STL header\n      // check for default color in header (\"COLOR=rgba\" sequence).\n\n      for (let index = 0; index < 80 - 10; index++) {\n        if ((reader.getUint32(index, false) == 0x434F4C4F /* COLO */)\n          && (reader.getUint8(index + 4) == 0x52 /* 'R' */)\n          && (reader.getUint8(index + 5) == 0x3D /* '=' */)) {\n          hasColors = true\n          colors = []\n\n          defaultR = reader.getUint8(index + 6) / 255\n          defaultG = reader.getUint8(index + 7) / 255\n          defaultB = reader.getUint8(index + 8) / 255\n          alpha = reader.getUint8(index + 9) / 255\n        }\n      }\n\n      const dataOffset = 84\n      const faceLength = 12 * 4 + 2\n\n      const geometry = new THREE.BufferGeometry()\n\n      const vertices = []\n      const normals = []\n\n      for (let face = 0; face < faces; face++) {\n        const start = dataOffset + face * faceLength\n        const normalX = reader.getFloat32(start, true)\n        const normalY = reader.getFloat32(start + 4, true)\n        const normalZ = reader.getFloat32(start + 8, true)\n\n        if (hasColors) {\n          const packedColor = reader.getUint16(start + 48, true)\n\n          if ((packedColor & 0x8000) === 0) {\n            // facet has its own unique color\n\n            r = (packedColor & 0x1F) / 31\n            g = ((packedColor >> 5) & 0x1F) / 31\n            b = ((packedColor >> 10) & 0x1F) / 31\n          } else {\n            r = defaultR\n            g = defaultG\n            b = defaultB\n          }\n        }\n\n        for (let i = 1; i <= 3; i++) {\n          const vertexstart = start + i * 12\n\n          vertices.push(reader.getFloat32(vertexstart, true))\n          vertices.push(reader.getFloat32(vertexstart + 4, true))\n          vertices.push(reader.getFloat32(vertexstart + 8, true))\n\n          normals.push(normalX, normalY, normalZ)\n\n          if (hasColors) {\n            colors.push(r, g, b)\n          }\n        }\n      }\n\n      geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3))\n      geometry.addAttribute('normal', new THREE.BufferAttribute(new Float32Array(normals), 3))\n\n      if (hasColors) {\n        geometry.addAttribute('color', new THREE.BufferAttribute(new Float32Array(colors), 3))\n        geometry.hasColors = true\n        geometry.alpha = alpha\n      }\n\n      return geometry\n    }\n\n    function parseASCII(data) {\n      const geometry = new THREE.BufferGeometry()\n      const patternFace = /facet([\\s\\S]*?)endfacet/g\n      let faceCounter = 0\n\n      const patternFloat = /[\\s]+([+-]?(?:\\d*)(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/.source\n      const patternVertex = new RegExp(`vertex${patternFloat}${patternFloat}${patternFloat}`, 'g')\n      const patternNormal = new RegExp(`normal${patternFloat}${patternFloat}${patternFloat}`, 'g')\n\n      const vertices = []\n      const normals = []\n\n      const normal = new THREE.Vector3()\n\n      let result\n\n      while ((result = patternFace.exec(data)) !== null) {\n        let vertexCountPerFace = 0\n        let normalCountPerFace = 0\n\n        const text = result[0]\n\n        while ((result = patternNormal.exec(text)) !== null) {\n          normal.x = parseFloat(result[1])\n          normal.y = parseFloat(result[2])\n          normal.z = parseFloat(result[3])\n          normalCountPerFace++\n        }\n\n        while ((result = patternVertex.exec(text)) !== null) {\n          vertices.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]))\n          normals.push(normal.x, normal.y, normal.z)\n          vertexCountPerFace++\n        }\n\n        // every face have to own ONE valid normal\n\n        if (normalCountPerFace !== 1) {\n          console.error(`THREE.STLLoader: Something isn't right with the normal of face number ${faceCounter}`)\n        }\n\n        // each face have to own THREE valid vertices\n\n        if (vertexCountPerFace !== 3) {\n          console.error(`THREE.STLLoader: Something isn't right with the vertices of face number ${faceCounter}`)\n        }\n\n        faceCounter++\n      }\n\n      geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n      geometry.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3))\n\n      return geometry\n    }\n\n    function ensureString(buffer) {\n      if (typeof buffer !== 'string') {\n        return THREE.LoaderUtils.decodeText(new Uint8Array(buffer))\n      }\n\n      return buffer\n    }\n\n    function ensureBinary(buffer) {\n      if (typeof buffer === 'string') {\n        const array_buffer = new Uint8Array(buffer.length)\n        for (let i = 0; i < buffer.length; i++) {\n          array_buffer[i] = buffer.charCodeAt(i) & 0xff // implicitly assumes little-endian\n        }\n        return array_buffer.buffer || array_buffer\n      }\n\n      return buffer\n    }\n\n    // start\n\n    const binData = ensureBinary(data)\n\n    return isBinary(binData) ? parseBinary(binData) : parseASCII(ensureString(data))\n  },\n\n}\n\n\nexport default STLLoader\n","import * as THREE from 'three'\n\n/* global document */\n\n/**\n* Some handy static functions to do stuff that are not strictly related to the business of the project\n*/\nclass Tools {\n  /**\n   * Handy function to deal with option object we pass in argument of function.\n   * Allows the return of a default value if the `optionName` is not available in\n   * the `optionObj`\n   * @param {Object} optionObj - the object that contain the options\n   * @param {String} optionName - the name of the option desired, attribute of `optionObj`\n   * @param {any} optionDefaultValue - default values to be returned in case `optionName` is not an attribute of `optionObj`\n   */\n  static getOption(optionObj, optionName, optionDefaultValue) {\n    return (optionObj && optionName in optionObj) ? optionObj[optionName] : optionDefaultValue\n  }\n\n\n  /**\n   * @private\n   * Generate a cylinder with a starting point and en endpoint because\n   * THREEjs does not provide that\n   * @param {THREE.Vector3} vStart - the start position\n   * @param {THREE.Vector3} vEnd - the end position\n   * @param {Number} rStart - radius at the `vStart` position\n   * @param {Number} rEnd - radius at the `vEnd` position\n   * @param {Boolean} openEnd - cylinder has open ends if true, or closed ends if false\n   * @return {THREE.CylinderBufferGeometry} the mesh containing a cylinder\n   */\n  static makeCylinder(vStart, vEnd, rStart, rEnd, openEnd) {\n    const HALF_PI = Math.PI * 0.5\n    const distance = vStart.distanceTo(vEnd)\n    const position = vEnd.clone().add(vStart).divideScalar(2)\n\n    const offsetPosition = new THREE.Matrix4()// a matrix to fix pivot position\n    offsetPosition.setPosition(position)\n\n    const cylinder = new THREE.CylinderBufferGeometry(rStart, rEnd, distance, 32, 1, openEnd)\n    const orientation = new THREE.Matrix4()// a new orientation matrix to offset pivot\n    orientation.multiply(offsetPosition) // test to add offset\n    const offsetRotation = new THREE.Matrix4()// a matrix to fix pivot rotation\n    orientation.lookAt(vStart, vEnd, new THREE.Vector3(0, 1, 0))// look at destination\n    offsetRotation.makeRotationX(HALF_PI)// rotate 90 degs on X\n    orientation.multiply(offsetRotation)// combine orientation with rotation transformations\n    cylinder.applyMatrix(orientation)\n    return cylinder\n  }\n\n\n  static triggerDownload(strData, filename) {\n    const link = document.createElement('a')\n    document.body.appendChild(link) // Firefox requires the link to be in the body\n    link.download = filename\n    link.href = strData\n    link.click()\n    document.body.removeChild(link) // remove the link when done\n  }\n}\n\nexport default Tools\n","/*\n* Author   Jonathan Lurie - http://me.jonathanlurie.fr\n* License  MIT\n* Link     https://github.com/Pixpipe/quickvoxelcore\n* Lab      MCIN - Montreal Neurological Institute\n*/\n\n\n/**\n * The EventManager deals with events, create them, call them.\n * This class is mostly for being inherited from.\n */\nclass EventManager {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this._events = {}\n  }\n\n\n  /**\n   * Define an event, with a name associated with a function\n   * @param  {String} eventName - Name to give to the event\n   * @param  {Function} callback - function associated to the even\n   */\n  on(eventName, callback) {\n    if (typeof callback === 'function') {\n      if (!(eventName in this._events)) {\n        this._events[eventName] = []\n      }\n      this._events[eventName].push(callback)\n    } else {\n      console.warn('The callback must be of type Function')\n    }\n  }\n\n\n  emit(eventName, args = []) {\n    // the event must exist and be non null\n    if ((eventName in this._events) && (this._events[eventName].length > 0)) {\n      const events = this._events[eventName]\n      for (let i = 0; i < events.length; i += 1) {\n        events[i](...args)\n      }\n    } else {\n      console.warn(`No function associated to the event ${eventName}`)\n    }\n  }\n}\n\nexport default EventManager\n","import * as THREE from \"three-canvas-renderer\";\nimport ObjParser from \"parse-wavefront-obj\";\nimport { Canvas } from \"canvas\";\nimport raf from \"raf\";\nimport STLLoader from \"./thirdparty/STLLoader\";\nimport Tools from \"./Tools\";\nimport EventManager from \"./EventManager\";\n\n// eslint thing\n/* global window requestAnimationFrame cancelAnimationFrame */\n\nconst DEFAULT_FOCUS_DISTANCE = 1000;\n\n/**\n * ThreeContext creates a WebGL context using THREEjs. It also handle mouse control.\n * A MorphologyPolyline instance is added to it.\n * An event can be associated to a ThreeContext instance: `onRaycast` with the method\n * `.on(\"onRaycast\", function(s){...})` where `s` is the section object being raycasted.\n */\nclass ThreeContext extends EventManager {\n  /**\n   * @param {DONObject} divObj - the div object as a DOM element.\n   * Will be used to host the WebGL context\n   * created by THREE\n   */\n  constructor(canvas) {\n    super();\n    const that = this;\n\n    this._canvas = canvas;\n\n    this._requestFrameId = null;\n\n    this._morphologyMeshCollection = {};\n    this._meshCollection = {};\n\n    // init camera\n    this._camera = new THREE.PerspectiveCamera(27, 1, 1, 1000000);\n    this._camera.position.z = DEFAULT_FOCUS_DISTANCE;\n\n    // init scene\n    this._scene = new THREE.Scene();\n    this._scene.add(new THREE.AmbientLight(0x444444));\n\n    // let axesHelper = new THREE.AxesHelper( 1000 )\n    // this._scene.add( axesHelper )\n\n    // adding some light\n    const light1 = new THREE.DirectionalLight(0xffffff, 0.8);\n    //light1.position.set(0, 1000, 0)\n    // adding the light to the camera ensure a constant lightin of the model\n    this._scene.add(this._camera);\n    this._camera.add(light1);\n\n    // @ts-ignore\n    this._canvas.style = {}; // dummy shim to prevent errors during render.setSize\n\n    this._renderer = new THREE.CanvasRenderer({\n      canvas: this._canvas,\n      alpha: true\n      // preserveDrawingBuffer: true,\n    });\n\n    this._renderer.setClearColor(0xffffff, 0);\n    this._renderer.setSize(600, 600);\n    this._renderer.render(this._scene, this._camera);\n\n    // all the necessary for raycasting\n    this._raycaster = new THREE.Raycaster();\n    this._raycastMouse = new THREE.Vector2();\n\n    // function onMouseMove(event) {\n    //   const elem = that._renderer.domElement\n    //   const rect = elem.getBoundingClientRect()\n    //   const relX = event.clientX - rect.left\n    //   const relY = event.clientY - rect.top\n    //   that._raycastMouse.x =        (relX / that._renderer.domElement.clientWidth) * 2 - 1\n    //   that._raycastMouse.y =        -(relY / that._renderer.domElement.clientHeight) * 2 + 1\n    // }\n\n    // this._renderer.domElement.addEventListener('mousemove', onMouseMove, false)\n    // this._renderer.domElement.addEventListener(\n    //   'dblclick',\n    //   () => {\n    //     this._performRaycast()\n    //   },\n    //   false,\n    // )\n\n    // mouse controls\n    // this._controls = new TrackballControls(\n    //   this._camera,\n    //   this._renderer.domElement,\n    // )\n    // this._controls.rotateSpeed = 3\n    // this._controls.addEventListener('change', this._render.bind(this))\n\n    // window.addEventListener(\n    //   'resize',\n    //   () => {\n    //     that._camera.aspect = divObj.clientWidth / divObj.clientHeight\n    //     that._camera.updateProjectionMatrix()\n    //     that._renderer.setSize(divObj.clientWidth, divObj.clientHeight)\n    //     that._controls.handleResize()\n    //     that._render()\n    //   },\n    //   false,\n    // )\n\n    this._testObjMesh();\n\n    this._render();\n    // this._animate()\n  }\n\n  _testObjMesh() {\n    OBJLoader2;\n  }\n\n  /**\n   * Get the field of view angle of the camera, in degrees\n   * @return {Number}\n   */\n  getCameraFieldOfView() {\n    return this._camera.fov;\n  }\n\n  /**\n   * Define the camera field of view, in degrees\n   * @param {Number} fov - the fov\n   */\n  setCameraFieldOfView(fov) {\n    this._camera.fov = fov;\n    this._camera.updateProjectionMatrix();\n    this._render();\n  }\n\n  /**\n   * Adds a mesh from its URL. The mesh has to encoded into the STL format\n   * @param {String} url - the url of the STL file\n   * @param {Object} options - the options object\n   * @param {String} options.name - optional name of this mesh (useful for further operations such as centering the view)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added mesh. If false, the camera will not change\n   * @param {Number} options.opacity - the opacity of the mesh\n   * @param {Number} options.color - the color of the mesh\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Function} options.onDone - callback to be called when the mesh is added. Called with the name of the mesh in argument\n   */\n  addStlToMeshCollection(url, options) {\n    const that = this;\n\n    // generate a random name in case none was provided\n    const name = Tools.getOption(\n      options,\n      \"name\",\n      `mesh_${Math.round(Math.random() * 1000000).toString()}`\n    );\n    const focusOn = Tools.getOption(options, \"focusOn\", true);\n\n    const loader = new STLLoader();\n    // loader.load( '../data/meshes/mask_smooth_simple.stl', function ( geometry ) {\n    loader.load(url, geometry => {\n      const material = this._buildMeshMaterialFromOptions(options);\n\n      geometry.computeBoundingSphere();\n\n      const mesh = new THREE.Mesh(geometry, material);\n\n      mesh.userData.name = name;\n\n      that._scene.add(mesh);\n      that._meshCollection[name] = mesh;\n\n      if (focusOn) that.focusOnMesh(name);\n\n      // call a callback if declared, with the name of the mesh in arg\n      const onDone = Tools.getOption(options, \"onDone\", null);\n      if (onDone) {\n        onDone(name);\n      }\n      this._render();\n    });\n  }\n\n  /**\n   * @private\n   * Generates a phong material based on the options provided\n   */\n  _buildMeshMaterialFromOptions(options) {\n    const color = Tools.getOption(\n      options,\n      \"color\",\n      Math.floor(Math.random() * 0xffffff)\n    );\n    const opacity = Tools.getOption(options, \"opacity\", 0.15);\n    const wireframe = Tools.getOption(options, \"wireframe\", false);\n    const shininess = Tools.getOption(options, \"shininess\", 300);\n    const doubleSide = Tools.getOption(options, \"doubleSide\", false);\n\n    const material = new THREE.MeshPhongMaterial({\n      specular: 0xffffff,\n      shininess,\n      side: doubleSide ? THREE.DoubleSide : THREE.FrontSide,\n      color,\n      transparent: true,\n      opacity,\n      wireframe\n    });\n\n    return material;\n  }\n\n  /**\n   * Add a OBJ mesh to the scene\n   * @param {String} objStr - string that comes from the obj file\n   * @param {Object} options - the options object\n   * @param {String} options.name - optional name of this mesh (useful for further operations such as centering the view)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added mesh. If false, the camera will not change\n   * @param {Number} options.opacity - the opacity of the mesh\n   * @param {Number} options.color - the color of the mesh\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Function} options.onDone - callback to be called when the mesh is added. Called with the name of the mesh in argument\n   */\n  addObjToMeshCollection(objStr, options) {\n    // generate a random name in case none was provided\n    const name = Tools.getOption(\n      options,\n      \"name\",\n      `mesh_${Math.round(Math.random() * 1000000).toString()}`\n    );\n    const focusOn = Tools.getOption(options, \"focusOn\", true);\n    let meshData = ObjParser(objStr);\n\n    // Usually 3 because polygons are triangle, but OBJ allows different\n    const verticesPerPolygon = meshData.cells[0].length;\n    let indices = new Uint32Array(verticesPerPolygon * meshData.cells.length);\n    let positions = new Float32Array(3 * meshData.positions.length);\n\n    // flattening the indices\n    for (let i = 0; i < meshData.cells.length; i += 1) {\n      const newIndex = i * verticesPerPolygon;\n      for (let ii = 0; ii < verticesPerPolygon; ii += 1) {\n        indices[newIndex + ii] = meshData.cells[i][ii];\n      }\n    }\n\n    // flatening the positions\n    for (let p = 0; p < meshData.positions.length; p += 1) {\n      const newIndex = p * 3;\n      positions[newIndex] = meshData.positions[p][0];\n      positions[newIndex + 1] = meshData.positions[p][1];\n      positions[newIndex + 2] = meshData.positions[p][2];\n    }\n\n    const geometry = new THREE.BufferGeometry();\n    geometry.setIndex(new THREE.BufferAttribute(indices, 1));\n    geometry.addAttribute(\n      \"position\",\n      new THREE.BufferAttribute(positions, verticesPerPolygon)\n    );\n    geometry.computeBoundingSphere();\n    geometry.computeVertexNormals();\n\n    // Allen atlas being inverted\n    geometry.rotateX(Math.PI);\n    geometry.rotateY(Math.PI);\n\n    const material = this._buildMeshMaterialFromOptions(options);\n\n    const mesh = new THREE.Mesh(geometry, material);\n\n    mesh.userData.name = name;\n    this._scene.add(mesh);\n    this._meshCollection[name] = mesh;\n\n    if (focusOn) this.focusOnMesh(name);\n\n    // call a callback if declared, with the name of the mesh in arg\n    const onDone = Tools.getOption(options, \"onDone\", null);\n    if (onDone) {\n      onDone(name);\n    }\n    this._render();\n  }\n\n  // /**\n  //  * @private\n  //  * deals with rendering and updating the controls\n  //  */\n  // _animate() {\n  //   this._requestFrameId = raf(this._animate.bind(this))\n  //   // this._controls.update()\n  // }\n\n  _render() {\n    this._renderer.render(this._scene, this._camera);\n  }\n\n  /**\n   * @private\n   * Throw a ray from the camera to the pointer, potentially intersect some sections.\n   * If so, emit the event `onRaycast` with the section instance as argument\n   */\n  _performRaycast() {\n    // update the picking ray with the camera and mouse position\n    this._raycaster.setFromCamera(this._raycastMouse, this._camera);\n\n    // calculate objects intersecting the picking ray\n    const intersects = this._raycaster.intersectObjects(\n      this._scene.children,\n      true\n    );\n\n    if (intersects.length) {\n      // console.log(this._morphologyMeshCollection)\n      const sectionMesh = intersects[0].object;\n\n      // if it's the section of a morphology\n      if (\"sectionId\" in sectionMesh.userData) {\n        const { sectionId } = sectionMesh.userData;\n        const morphologyObj = sectionMesh.parent.getMorphology();\n        this.emit(\"onRaycast\", [morphologyObj._sections[sectionId]]);\n\n        // If it's another mesh\n      } else if (\"name\" in sectionMesh.userData) {\n        this.emit(\"onRaycast\", [sectionMesh.userData.name]);\n\n        // here we are raycasting something that is not identified\n      } else {\n        this.emit(\"onRaycast\", [null]);\n      }\n    }\n  }\n\n  /**\n   * Add a MorphoPolyline object (which are ThreeJS Object3D) into the scene of this\n   * ThreeContext.\n   * @param {MorphoPolyline} morphoMesh - a MorphoPolyline instance\n   * @param {Object} options - the option object\n   * @param {String} options.name - the identifier to give to the MorphoPolyline instance within a local collection\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added morphology. If false, the camera will not change\n   * @param {Function} options.onDone - callback to be called when the morphology polyline is added. Called with the name of the morpho in argument\n   */\n  addMorphology(morphoMesh, options) {\n    // generate a random name in case none was provided\n    const name = options.name; // set before\n    const focusOn = Tools.getOption(options, \"focusOn\", true);\n    const focusDistance = Tools.getOption(\n      options,\n      \"distance\",\n      DEFAULT_FOCUS_DISTANCE\n    );\n\n    this._morphologyMeshCollection[name] = morphoMesh;\n    this._scene.add(morphoMesh);\n\n    if (focusOn) this.focusOnMorphology(name, focusDistance);\n\n    // call a callback if declared, with the name of the morphology in arg\n    const onDone = Tools.getOption(options, \"onDone\");\n    if (onDone) {\n      onDone(name);\n    }\n\n    this._render();\n  }\n\n  /**\n   * Make the camera focus on a specific morphology\n   * @param {String|null} name - name of the morphology in the collection. If `null`, takes the first one\n   */\n  focusOnMorphology(name = null, distance = DEFAULT_FOCUS_DISTANCE) {\n    let morphoName = name;\n    // if no name of morphology is provided, we take the first one\n    if (!morphoName) {\n      const allNames = Object.keys(this._morphologyMeshCollection);\n      if (allNames.length) {\n        morphoName = allNames[0];\n      } else {\n        return;\n      }\n    }\n\n    const morpho = this._morphologyMeshCollection[morphoName];\n    const targetPoint = morpho.getTargetPoint();\n    // we try to get pretty close to the soma, hence the averageSide/5\n    this._camera.position.set(\n      targetPoint.x,\n      targetPoint.y,\n      targetPoint.z - distance\n    );\n    this._camera.lookAt(targetPoint);\n    // this._controls.target.copy(targetPoint)\n    this._render();\n  }\n\n  /**\n   * Focus on a mesh, given its name\n   * @param {string} name - name of the mesh to focus on\n   */\n  focusOnMesh(name) {\n    const mesh = this._meshCollection[name];\n    const boundingSphere = mesh.geometry.boundingSphere;\n\n    this._camera.position.set(\n      boundingSphere.center.x - boundingSphere.radius * 3,\n      boundingSphere.center.y,\n      boundingSphere.center.z\n    );\n    this._camera.lookAt(boundingSphere.center);\n    // this._controls.target.copy(boundingSphere.center)\n    this._render();\n  }\n\n  /**\n   * Get the png image data as base64, in order to later, export as a file\n   */\n  getSnapshotData() {\n    const strMime = \"image/png\";\n    // let strDownloadMime = \"image/octet-stream\"\n    // const imgData = this._renderer.domElement.toDataURL(strMime)\n    // imgData.replace(strMime, strDownloadMime)\n    return this._canvas.toBuffer(strMime);\n  }\n\n  /**\n   * Show the given mesh from the colelction\n   * @param {String} name - Name of the mesh\n   */\n  showMesh(name) {\n    if (name in this._meshCollection) {\n      this._meshCollection[name].material.visible = true;\n      this._render();\n    }\n  }\n\n  /**\n   * Hide the given mesh from the colelction\n   * @param {String} name - Name of the mesh\n   */\n  hideMesh(name) {\n    if (name in this._meshCollection) {\n      this._meshCollection[name].material.visible = false;\n      this._render();\n    }\n  }\n\n  /**\n   * Kills the scene, interaction, animation and reset all objects to null\n   */\n  destroy() {\n    // this._controls.dispose()\n    raf.cancel(this._requestFrameId);\n    this._camera = null;\n    // this._controls = null\n    this._scene = null;\n    this._morphologyMeshCollection = null;\n    this._meshCollection = null;\n    this._renderer = null;\n    this._canvas = null;\n  }\n}\n\nexport default ThreeContext;\n","/*\n* @author Mugen87 / https://github.com/Mugen87\n*\n* Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n*\n*/\n\nimport * as THREE from 'three'\n\n\nconst Visible = 0\nconst Deleted = 1\n\nfunction QuickHull() {\n  this.tolerance = -1\n\n  this.faces = [] // the generated faces of the convex hull\n  this.newFaces = [] // this array holds the faces that are generated within a single iteration\n\n  // the vertex lists work as follows:\n  //\n  // let 'a' and 'b' be 'Face' instances\n  // let 'v' be points wrapped as instance of 'Vertex'\n  //\n  //     [v, v, ..., v, v, v, ...]\n  //      ^             ^\n  //      |             |\n  //  a.outside     b.outside\n  //\n  this.assigned = new VertexList()\n  this.unassigned = new VertexList()\n\n  this.vertices = [] // vertices of the hull (internal representation of given geometry data)\n}\n\nObject.assign(QuickHull.prototype, {\n\n  setFromPoints(points) {\n    if (Array.isArray(points) !== true) {\n      console.error('THREE.QuickHull: Points parameter is not an array.')\n    }\n\n    if (points.length < 4) {\n      console.error('THREE.QuickHull: The algorithm needs at least four points.')\n    }\n\n    this.makeEmpty()\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      this.vertices.push(new VertexNode(points[i]))\n    }\n\n    this.compute()\n\n    return this\n  },\n\n  setFromObject(object) {\n    const points = []\n\n    object.updateMatrixWorld(true)\n\n    object.traverse((node) => {\n      let i; let l; let\n        point\n\n      const geometry = node.geometry\n\n      if (geometry !== undefined) {\n        if (geometry.isGeometry) {\n          const vertices = geometry.vertices\n\n          for (i = 0, l = vertices.length; i < l; i++) {\n            point = vertices[i].clone()\n            point.applyMatrix4(node.matrixWorld)\n\n            points.push(point)\n          }\n        } else if (geometry.isBufferGeometry) {\n          const attribute = geometry.attributes.position\n\n          if (attribute !== undefined) {\n            for (i = 0, l = attribute.count; i < l; i++) {\n              point = new THREE.Vector3()\n\n              point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld)\n\n              points.push(point)\n            }\n          }\n        }\n      }\n    })\n\n    return this.setFromPoints(points)\n  },\n\n  makeEmpty() {\n    this.faces = []\n    this.vertices = []\n\n    return this\n  },\n\n  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n  addVertexToFace(vertex, face) {\n    vertex.face = face\n\n    if (face.outside === null) {\n      this.assigned.append(vertex)\n    } else {\n      this.assigned.insertBefore(face.outside, vertex)\n    }\n\n    face.outside = vertex\n\n    return this\n  },\n\n  // Removes a vertex from the 'assigned' list of vertices and from the given face\n\n  removeVertexFromFace(vertex, face) {\n    if (vertex === face.outside) {\n      // fix face.outside link\n\n      if (vertex.next !== null && vertex.next.face === face) {\n        // face has at least 2 outside vertices, move the 'outside' reference\n\n        face.outside = vertex.next\n      } else {\n        // vertex was the only outside vertex that face had\n\n        face.outside = null\n      }\n    }\n\n    this.assigned.remove(vertex)\n\n    return this\n  },\n\n  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n  removeAllVerticesFromFace(face) {\n    if (face.outside !== null) {\n      // reference to the first and last vertex of this face\n\n      const start = face.outside\n      let end = face.outside\n\n      while (end.next !== null && end.next.face === face) {\n        end = end.next\n      }\n\n      this.assigned.removeSubList(start, end)\n\n      // fix references\n\n      start.prev = end.next = null\n      face.outside = null\n\n      return start\n    }\n  },\n\n  // Removes all the visible vertices that 'face' is able to see\n\n  deleteFaceVertices(face, absorbingFace) {\n    const faceVertices = this.removeAllVerticesFromFace(face)\n\n    if (faceVertices !== undefined) {\n      if (absorbingFace === undefined) {\n        // mark the vertices to be reassigned to some other face\n\n        this.unassigned.appendChain(faceVertices)\n      } else {\n        // if there's an absorbing face try to assign as many vertices as possible to it\n\n        let vertex = faceVertices\n\n        do {\n          // we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n          // will be changed by upcoming method calls\n\n          const nextVertex = vertex.next\n\n          const distance = absorbingFace.distanceToPoint(vertex.point)\n\n          // check if 'vertex' is able to see 'absorbingFace'\n\n          if (distance > this.tolerance) {\n            this.addVertexToFace(vertex, absorbingFace)\n          } else {\n            this.unassigned.append(vertex)\n          }\n\n          // now assign next vertex\n\n          vertex = nextVertex\n        } while (vertex !== null)\n      }\n    }\n\n    return this\n  },\n\n  // Reassigns as many vertices as possible from the unassigned list to the new faces\n\n  resolveUnassignedPoints(newFaces) {\n    if (this.unassigned.isEmpty() === false) {\n      let vertex = this.unassigned.first()\n\n      do {\n        // buffer 'next' reference, see .deleteFaceVertices()\n\n        const nextVertex = vertex.next\n\n        let maxDistance = this.tolerance\n\n        let maxFace = null\n\n        for (let i = 0; i < newFaces.length; i++) {\n          const face = newFaces[i]\n\n          if (face.mark === Visible) {\n            const distance = face.distanceToPoint(vertex.point)\n\n            if (distance > maxDistance) {\n              maxDistance = distance\n              maxFace = face\n            }\n\n            if (maxDistance > 1000 * this.tolerance) break\n          }\n        }\n\n        // 'maxFace' can be null e.g. if there are identical vertices\n\n        if (maxFace !== null) {\n          this.addVertexToFace(vertex, maxFace)\n        }\n\n        vertex = nextVertex\n      } while (vertex !== null)\n    }\n\n    return this\n  },\n\n  // Computes the extremes of a simplex which will be the initial hull\n\n  computeExtremes() {\n    const min = new THREE.Vector3()\n    const max = new THREE.Vector3()\n\n    const minVertices = []\n    const maxVertices = []\n\n    let i; let l; let\n      j\n\n    // initially assume that the first vertex is the min/max\n\n    for (i = 0; i < 3; i++) {\n      minVertices[i] = maxVertices[i] = this.vertices[0]\n    }\n\n    min.copy(this.vertices[0].point)\n    max.copy(this.vertices[0].point)\n\n    // compute the min/max vertex on all six directions\n\n    for (i = 0, l = this.vertices.length; i < l; i++) {\n      const vertex = this.vertices[i]\n      const point = vertex.point\n\n      // update the min coordinates\n\n      for (j = 0; j < 3; j++) {\n        if (point.getComponent(j) < min.getComponent(j)) {\n          min.setComponent(j, point.getComponent(j))\n          minVertices[j] = vertex\n        }\n      }\n\n      // update the max coordinates\n\n      for (j = 0; j < 3; j++) {\n        if (point.getComponent(j) > max.getComponent(j)) {\n          max.setComponent(j, point.getComponent(j))\n          maxVertices[j] = vertex\n        }\n      }\n    }\n\n    // use min/max vectors to compute an optimal epsilon\n\n    this.tolerance = 3 * Number.EPSILON * (\n      Math.max(Math.abs(min.x), Math.abs(max.x))\n      + Math.max(Math.abs(min.y), Math.abs(max.y))\n      + Math.max(Math.abs(min.z), Math.abs(max.z))\n    )\n\n    return { min: minVertices, max: maxVertices }\n  },\n\n  // Computes the initial simplex assigning to its faces all the points\n  // that are candidates to form part of the hull\n\n  computeInitialHull: (function () {\n    let line3; let plane; let\n      closestPoint\n\n    return function computeInitialHull() {\n      if (line3 === undefined) {\n        line3 = new THREE.Line3()\n        plane = new THREE.Plane()\n        closestPoint = new THREE.Vector3()\n      }\n\n      let vertex; const\n        vertices = this.vertices\n      const extremes = this.computeExtremes()\n      const min = extremes.min\n      const max = extremes.max\n\n      let v0; let v1; let v2; let\n        v3\n      let i; let l; let\n        j\n\n      // 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n      // (max.x - min.x)\n      // (max.y - min.y)\n      // (max.z - min.z)\n\n      let distance; let\n        maxDistance = 0\n      let index = 0\n\n      for (i = 0; i < 3; i++) {\n        distance = max[i].point.getComponent(i) - min[i].point.getComponent(i)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          index = i\n        }\n      }\n\n      v0 = min[index]\n      v1 = max[index]\n\n      // 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n      maxDistance = 0\n      line3.set(v0.point, v1.point)\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        vertex = vertices[i]\n\n        if (vertex !== v0 && vertex !== v1) {\n          line3.closestPointToPoint(vertex.point, true, closestPoint)\n\n          distance = closestPoint.distanceToSquared(vertex.point)\n\n          if (distance > maxDistance) {\n            maxDistance = distance\n            v2 = vertex\n          }\n        }\n      }\n\n      // 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n      maxDistance = -1\n      plane.setFromCoplanarPoints(v0.point, v1.point, v2.point)\n\n      for (i = 0, l = this.vertices.length; i < l; i++) {\n        vertex = vertices[i]\n\n        if (vertex !== v0 && vertex !== v1 && vertex !== v2) {\n          distance = Math.abs(plane.distanceToPoint(vertex.point))\n\n          if (distance > maxDistance) {\n            maxDistance = distance\n            v3 = vertex\n          }\n        }\n      }\n\n      const faces = []\n\n      if (plane.distanceToPoint(v3.point) < 0) {\n        // the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n        faces.push(\n          Face.create(v0, v1, v2),\n          Face.create(v3, v1, v0),\n          Face.create(v3, v2, v1),\n          Face.create(v3, v0, v2),\n        )\n\n        // set the twin edge\n\n        for (i = 0; i < 3; i++) {\n          j = (i + 1) % 3\n\n          // join face[ i ] i > 0, with the first face\n\n          faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j))\n\n          // join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n          faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0))\n        }\n      } else {\n        // the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n        faces.push(\n          Face.create(v0, v2, v1),\n          Face.create(v3, v0, v1),\n          Face.create(v3, v1, v2),\n          Face.create(v3, v2, v0),\n        )\n\n        // set the twin edge\n\n        for (i = 0; i < 3; i++) {\n          j = (i + 1) % 3\n\n          // join face[ i ] i > 0, with the first face\n\n          faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3))\n\n          // join face[ i ] with face[ i + 1 ]\n\n          faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1))\n        }\n      }\n\n      // the initial hull is the tetrahedron\n\n      for (i = 0; i < 4; i++) {\n        this.faces.push(faces[i])\n      }\n\n      // initial assignment of vertices to the faces of the tetrahedron\n\n      for (i = 0, l = vertices.length; i < l; i++) {\n        vertex = vertices[i]\n\n        if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {\n          maxDistance = this.tolerance\n          let maxFace = null\n\n          for (j = 0; j < 4; j++) {\n            distance = this.faces[j].distanceToPoint(vertex.point)\n\n            if (distance > maxDistance) {\n              maxDistance = distance\n              maxFace = this.faces[j]\n            }\n          }\n\n          if (maxFace !== null) {\n            this.addVertexToFace(vertex, maxFace)\n          }\n        }\n      }\n\n      return this\n    }\n  }()),\n\n  // Removes inactive faces\n\n  reindexFaces() {\n    const activeFaces = []\n\n    for (let i = 0; i < this.faces.length; i++) {\n      const face = this.faces[i]\n\n      if (face.mark === Visible) {\n        activeFaces.push(face)\n      }\n    }\n\n    this.faces = activeFaces\n\n    return this\n  },\n\n  // Finds the next vertex to create faces with the current hull\n\n  nextVertexToAdd() {\n    // if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n    if (this.assigned.isEmpty() === false) {\n      let eyeVertex; let\n        maxDistance = 0\n\n      // grap the first available face and start with the first visible vertex of that face\n\n      const eyeFace = this.assigned.first().face\n      let vertex = eyeFace.outside\n\n      // now calculate the farthest vertex that face can see\n\n      do {\n        const distance = eyeFace.distanceToPoint(vertex.point)\n\n        if (distance > maxDistance) {\n          maxDistance = distance\n          eyeVertex = vertex\n        }\n\n        vertex = vertex.next\n      } while (vertex !== null && vertex.face === eyeFace)\n\n      return eyeVertex\n    }\n  },\n\n  // Computes a chain of half edges in CCW order called the 'horizon'.\n  // For an edge to be part of the horizon it must join a face that can see\n  // 'eyePoint' and a face that cannot see 'eyePoint'.\n\n  computeHorizon(eyePoint, crossEdge, face, horizon) {\n    // moves face's vertices to the 'unassigned' vertex list\n\n    this.deleteFaceVertices(face)\n\n    face.mark = Deleted\n\n    let edge\n\n    if (crossEdge === null) {\n      edge = crossEdge = face.getEdge(0)\n    } else {\n      // start from the next edge since 'crossEdge' was already analyzed\n      // (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n      edge = crossEdge.next\n    }\n\n    do {\n      const twinEdge = edge.twin\n      const oppositeFace = twinEdge.face\n\n      if (oppositeFace.mark === Visible) {\n        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {\n          // the opposite face can see the vertex, so proceed with next edge\n\n          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon)\n        } else {\n          // the opposite face can't see the vertex, so this edge is part of the horizon\n\n          horizon.push(edge)\n        }\n      }\n\n      edge = edge.next\n    } while (edge !== crossEdge)\n\n    return this\n  },\n\n  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n  addAdjoiningFace(eyeVertex, horizonEdge) {\n    // all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head())\n\n    this.faces.push(face)\n\n    // join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n    face.getEdge(-1).setTwin(horizonEdge.twin)\n\n    return face.getEdge(0) // the half edge whose vertex is the eyeVertex\n  },\n\n  //  Adds 'horizon.length' faces to the hull, each face will be linked with the\n  //  horizon opposite face and the face on the left/right\n\n  addNewFaces(eyeVertex, horizon) {\n    this.newFaces = []\n\n    let firstSideEdge = null\n    let previousSideEdge = null\n\n    for (let i = 0; i < horizon.length; i++) {\n      const horizonEdge = horizon[i]\n\n      // returns the right side edge\n\n      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge)\n\n      if (firstSideEdge === null) {\n        firstSideEdge = sideEdge\n      } else {\n        // joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n        sideEdge.next.setTwin(previousSideEdge)\n      }\n\n      this.newFaces.push(sideEdge.face)\n      previousSideEdge = sideEdge\n    }\n\n    // perform final join of new faces\n\n    firstSideEdge.next.setTwin(previousSideEdge)\n\n    return this\n  },\n\n  // Adds a vertex to the hull\n\n  addVertexToHull(eyeVertex) {\n    const horizon = []\n\n    this.unassigned.clear()\n\n    // remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n    this.removeVertexFromFace(eyeVertex, eyeVertex.face)\n\n    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon)\n\n    this.addNewFaces(eyeVertex, horizon)\n\n    // reassign 'unassigned' vertices to the new faces\n\n    this.resolveUnassignedPoints(this.newFaces)\n\n    return this\n  },\n\n  cleanup() {\n    this.assigned.clear()\n    this.unassigned.clear()\n    this.newFaces = []\n\n    return this\n  },\n\n  compute() {\n    let vertex\n\n    this.computeInitialHull()\n\n    // add all available vertices gradually to the hull\n\n    while ((vertex = this.nextVertexToAdd()) !== undefined) {\n      this.addVertexToHull(vertex)\n    }\n\n    this.reindexFaces()\n\n    this.cleanup()\n\n    return this\n  },\n\n})\n\n//\n\nfunction Face() {\n  this.normal = new THREE.Vector3()\n  this.midpoint = new THREE.Vector3()\n  this.area = 0\n\n  this.constant = 0 // signed distance from face to the origin\n  this.outside = null // reference to a vertex in a vertex list this face can see\n  this.mark = Visible\n  this.edge = null\n}\n\nObject.assign(Face, {\n\n  create(a, b, c) {\n    const face = new Face()\n\n    const e0 = new HalfEdge(a, face)\n    const e1 = new HalfEdge(b, face)\n    const e2 = new HalfEdge(c, face)\n\n    // join edges\n\n    e0.next = e2.prev = e1\n    e1.next = e0.prev = e2\n    e2.next = e1.prev = e0\n\n    // main half edge reference\n\n    face.edge = e0\n\n    return face.compute()\n  },\n\n})\n\nObject.assign(Face.prototype, {\n\n  getEdge(i) {\n    let edge = this.edge\n\n    while (i > 0) {\n      edge = edge.next\n      i--\n    }\n\n    while (i < 0) {\n      edge = edge.prev\n      i++\n    }\n\n    return edge\n  },\n\n  compute: (function () {\n    let triangle\n\n    return function compute() {\n      if (triangle === undefined) triangle = new THREE.Triangle()\n\n      const a = this.edge.tail()\n      const b = this.edge.head()\n      const c = this.edge.next.head()\n\n      triangle.set(a.point, b.point, c.point)\n\n      triangle.getNormal(this.normal)\n      triangle.getMidpoint(this.midpoint)\n      this.area = triangle.getArea()\n\n      this.constant = this.normal.dot(this.midpoint)\n\n      return this\n    }\n  }()),\n\n  distanceToPoint(point) {\n    return this.normal.dot(point) - this.constant\n  },\n\n})\n\n// Entity for a Doubly-Connected Edge List (DCEL).\n\nfunction HalfEdge(vertex, face) {\n  this.vertex = vertex\n  this.prev = null\n  this.next = null\n  this.twin = null\n  this.face = face\n}\n\nObject.assign(HalfEdge.prototype, {\n\n  head() {\n    return this.vertex\n  },\n\n  tail() {\n    return this.prev ? this.prev.vertex : null\n  },\n\n  length() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceTo(head.point)\n    }\n\n    return -1\n  },\n\n  lengthSquared() {\n    const head = this.head()\n    const tail = this.tail()\n\n    if (tail !== null) {\n      return tail.point.distanceToSquared(head.point)\n    }\n\n    return -1\n  },\n\n  setTwin(edge) {\n    this.twin = edge\n    edge.twin = this\n\n    return this\n  },\n\n})\n\n// A vertex as a double linked list node.\n\nfunction VertexNode(point) {\n  this.point = point\n  this.prev = null\n  this.next = null\n  this.face = null // the face that is able to see this vertex\n}\n\n// A double linked list that contains vertex nodes.\n\nfunction VertexList() {\n  this.head = null\n  this.tail = null\n}\n\nObject.assign(VertexList.prototype, {\n\n  first() {\n    return this.head\n  },\n\n  last() {\n    return this.tail\n  },\n\n  clear() {\n    this.head = this.tail = null\n\n    return this\n  },\n\n  // Inserts a vertex before the target vertex\n\n  insertBefore(target, vertex) {\n    vertex.prev = target.prev\n    vertex.next = target\n\n    if (vertex.prev === null) {\n      this.head = vertex\n    } else {\n      vertex.prev.next = vertex\n    }\n\n    target.prev = vertex\n\n    return this\n  },\n\n  // Inserts a vertex after the target vertex\n\n  insertAfter(target, vertex) {\n    vertex.prev = target\n    vertex.next = target.next\n\n    if (vertex.next === null) {\n      this.tail = vertex\n    } else {\n      vertex.next.prev = vertex\n    }\n\n    target.next = vertex\n\n    return this\n  },\n\n  // Appends a vertex to the end of the linked list\n\n  append(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n    vertex.next = null // the tail has no subsequent vertex\n\n    this.tail = vertex\n\n    return this\n  },\n\n  // Appends a chain of vertices where 'vertex' is the head.\n\n  appendChain(vertex) {\n    if (this.head === null) {\n      this.head = vertex\n    } else {\n      this.tail.next = vertex\n    }\n\n    vertex.prev = this.tail\n\n    // ensure that the 'tail' reference points to the last vertex of the chain\n\n    while (vertex.next !== null) {\n      vertex = vertex.next\n    }\n\n    this.tail = vertex\n\n    return this\n  },\n\n  // Removes a vertex from the linked list\n\n  remove(vertex) {\n    if (vertex.prev === null) {\n      this.head = vertex.next\n    } else {\n      vertex.prev.next = vertex.next\n    }\n\n    if (vertex.next === null) {\n      this.tail = vertex.prev\n    } else {\n      vertex.next.prev = vertex.prev\n    }\n\n    return this\n  },\n\n  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n  removeSubList(a, b) {\n    if (a.prev === null) {\n      this.head = b.next\n    } else {\n      a.prev.next = b.next\n    }\n\n    if (b.next === null) {\n      this.tail = a.prev\n    } else {\n      b.next.prev = a.prev\n    }\n\n    return this\n  },\n\n  isEmpty() {\n    return this.head === null\n  },\n\n})\n\n\nexport default QuickHull\n","/*\n* @author Mugen87 / https://github.com/Mugen87\n*/\n\nimport * as THREE from 'three'\nimport QuickHull from './QuickHull'\n\n\n// ConvexGeometry\n\nfunction ConvexGeometry(points) {\n  THREE.Geometry.call(this)\n\n  this.fromBufferGeometry(new ConvexBufferGeometry(points))\n  this.mergeVertices()\n}\n\nConvexGeometry.prototype = Object.create(THREE.Geometry.prototype)\nConvexGeometry.prototype.constructor = ConvexGeometry\n\n// ConvexBufferGeometry\n\nfunction ConvexBufferGeometry(points) {\n  THREE.BufferGeometry.call(this)\n\n  // buffers\n\n  const vertices = []\n  const normals = []\n\n  // execute QuickHull\n\n  if (QuickHull === undefined) {\n    console.error('THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on THREE.QuickHull')\n  }\n\n  const quickHull = new QuickHull().setFromPoints(points)\n\n  // generate vertices and normals\n\n  const faces = quickHull.faces\n\n  for (let i = 0; i < faces.length; i++) {\n    const face = faces[i]\n    let edge = face.edge\n\n    // we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n    do {\n      const point = edge.head().point\n\n      vertices.push(point.x, point.y, point.z)\n      normals.push(face.normal.x, face.normal.y, face.normal.z)\n\n      edge = edge.next\n    } while (edge !== face.edge)\n  }\n\n  // build geometry\n\n  this.addAttribute('position', new THREE.Float32BufferAttribute(vertices, 3))\n  this.addAttribute('normal', new THREE.Float32BufferAttribute(normals, 3))\n}\n\nConvexBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype)\nConvexBufferGeometry.prototype.constructor = ConvexBufferGeometry\n\n// export\n/*\nexport default ({\n  ConvexGeometry,\n  ConvexBufferGeometry,\n})\n*/\n\n\nexport { ConvexGeometry, ConvexBufferGeometry }\n","import * as THREE from 'three'\nimport Tools from './Tools'\nimport { ConvexBufferGeometry } from './thirdparty/ConvexGeometry'\n\n\n/**\n * This is the base class for `MorphologyPolyline` and `MorphologyPolycylinder`.\n * It handles the common features, mainly related to soma creation\n */\nclass MorphologyShapeBase extends THREE.Object3D {\n  /**\n   * @constructor\n   * Builds a moprho as a polyline\n   * @param {Object} morpho - raw object that describes a morphology (usually straight from a JSON file)\n   * @param {object} options - the option object\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   */\n  constructor(morpho, options) {\n    super()\n\n    this.userData.morphologyName = options.name\n    this._pointToTarget = null\n    this._morpho = morpho\n\n    // fetch the optional color\n    const color = Tools.getOption(options, 'color', null)\n\n    // simple color lookup, so that every section type is shown in a different color\n    this._sectionColors = {\n      axon: color || 0x1111ff,\n      basal_dendrite: color || 0xff1111,\n      apical_dendrite: color || 0xf442ad,\n    }\n  }\n\n\n  /**\n   * @private\n   * The method to build a soma mesh using the 'default' way, aka using simply the\n   * data from the soma.\n   * @return {THREE.Mesh} the soma mesh\n   */\n  _buildSomaDefault() {\n    const soma = this._morpho.getSoma()\n    const somaPoints = soma.getPoints()\n\n    // case when soma is a single point\n    if (somaPoints.length === 1) {\n      const somaSphere = new THREE.Mesh(\n        new THREE.SphereGeometry(soma.getRadius(), 32, 32),\n        new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }),\n      )\n\n      somaSphere.position.set(somaPoints[0][0], somaPoints[0][1], somaPoints[0][2])\n      return somaSphere\n\n    // this is a 3-point soma, probably colinear\n    } if (somaPoints.length === 3) {\n      /*\n      let radius = soma.getRadius()\n      let mat = new THREE.MeshPhongMaterial( {color: 0x000000, transparent: true, opacity:0.3} )\n\n      let c1 = Tools.makeCylinder(\n        new THREE.Vector3(...somaPoints[0]),\n        new THREE.Vector3(...somaPoints[1]),\n        radius,\n        radius,\n        false,\n        mat\n      )\n\n      let c2 = Tools.makeCylinder(\n        new THREE.Vector3(...somaPoints[1]),\n        new THREE.Vector3(...somaPoints[2]),\n        radius,\n        radius,\n        false,\n        mat\n      )\n\n      let somaCyl = new THREE.Object3D()\n      somaCyl.add(c1)\n      somaCyl.add(c2)\n      return somaCyl\n      */\n\n      const somaSphere = new THREE.Mesh(\n        new THREE.SphereGeometry(soma.getRadius(), 32, 32),\n        new THREE.MeshPhongMaterial({ color: 0x000000, transparent: true, opacity: 0.3 }),\n      )\n\n      somaSphere.position.set(somaPoints[0][0], somaPoints[0][1], somaPoints[0][2])\n      return somaSphere\n\n\n    // when soma is multiple points\n    } if (somaPoints.length > 1) {\n      // compute the average of the points\n      const center = soma.getCenter()\n      const centerV = new THREE.Vector3(center[0], center[1], center[2])\n      const geometry = new THREE.Geometry()\n\n      for (let i = 0; i < somaPoints.length; i += 1) {\n        geometry.vertices.push(\n          new THREE.Vector3(somaPoints[i][0], somaPoints[i][1], somaPoints[i][2]),\n          new THREE.Vector3(\n            somaPoints[(i + 1) % somaPoints.length][0],\n            somaPoints[(i + 1) % somaPoints.length][1],\n            somaPoints[(i + 1) % somaPoints.length][2],\n          ),\n          centerV,\n        )\n        geometry.faces.push(new THREE.Face3(3 * i, 3 * i + 1, 3 * i + 2))\n      }\n\n      const somaMesh = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({\n        color: 0x000000,\n        transparent: true,\n        opacity: 0.3,\n        side: THREE.DoubleSide,\n      }))\n      return somaMesh\n    }\n    console.warn('No soma defined')\n    return null\n  }\n\n\n  /**\n   * @private\n   * Here we build a soma convex polygon based on the 1st points of the orphan\n   * sections + the points available in the soma description\n   * @return {THREE.Mesh} the soma mesh\n   */\n  _buildSomaFromOrphanSections() {\n    const somaPoints = this._morpho.getSoma().getPoints()\n    let somaMesh = null\n\n    try {\n      // getting all the 1st points of orphan sections\n      const somaPolygonPoints = this._morpho.getOrphanSections().map((s) => {\n        const allPoints = s.getPoints()\n        const firstOne = allPoints[1]\n        return new THREE.Vector3(...firstOne)\n      })\n\n      // adding the points of the soma (adds values mostly if we a soma polygon)\n      for (let i = 0; i < somaPoints.length; i += 1) {\n        somaPolygonPoints.push(new THREE.Vector3(...somaPoints[i]))\n      }\n\n      const geometry = new ConvexBufferGeometry(somaPolygonPoints)\n      const material = new THREE.MeshPhongMaterial({\n        color: 0x555555,\n        transparent: true,\n        opacity: 0.7,\n        side: THREE.DoubleSide,\n      })\n      somaMesh = new THREE.Mesh(geometry, material)\n      return somaMesh\n    } catch (e) {\n      console.warn('Attempted to build a soma from orphan section points but failed. Back to the regular version.')\n      return this._buildSomaDefault()\n    }\n  }\n\n\n  /**\n   * @private\n   * Builds the soma. The type of soma depends on the option\n   * @param {Object} options - The option object\n   * @param {String|null} options.somaMode - \"default\" to display only the soma data or \"fromOrphanSections\" to build a soma using the orphan sections\n   */\n  _buildSoma(options) {\n    this._pointToTarget = this._morpho.getSoma().getCenter()\n    // can be 'default' or 'fromOrphanSections'\n    const buildMode = Tools.getOption(options, 'somaMode', null)\n    let somaMesh = null\n\n    if (buildMode === 'fromOrphanSections') {\n      somaMesh = this._buildSomaFromOrphanSections()\n    } else {\n      somaMesh = this._buildSomaDefault()\n    }\n\n    return somaMesh\n  }\n\n\n  /**\n   * Get the point to target when using the method lookAt. If the soma is valid,\n   * this will be the center of the soma. If no soma is valid, it will be the\n   * center of the box\n   * @return {Array} center with the shape [x: Number, y: Number, z: Number]\n   */\n  getTargetPoint() {\n    if (this._pointToTarget) {\n      // rotate this because Allen needs it (just like the sections)\n      const lookat = new THREE.Vector3(this._pointToTarget[0], this._pointToTarget[1], this._pointToTarget[2])\n      lookat.applyAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI)\n      lookat.applyAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI)\n      return lookat\n    }\n    const center = new THREE.Vector3()\n    this.box.getCenter(center)\n    return center\n  }\n\n\n  /**\n   * Get the morphology object tied to _this_ mesh\n   * @return {morphologycorejs.Morphology}\n   */\n  getMorphology() {\n    return this._morpho\n  }\n}\n\n\nexport default MorphologyShapeBase\n","import * as THREE from 'three'\nimport MorphologyShapeBase from './MorphologyShapeBase'\n\n/**\n * The MorphologyPolyline is the simplest 3D representation of a morphology, using\n * simple polylines.\n * Compared to its cylinder-based alternative (MorphologyPolycylinder), this one\n * is more suitable for displaying several morphologies (up to maybe a hundred,\n * depending on length and machine performance)\n * MorphologyPolyline extends from THREE.Object so that it's easy to integrate.\n * It's constructor\n */\nclass MorphologyPolyline extends MorphologyShapeBase {\n  /**\n   * @constructor\n   * Builds a moprho as a polyline\n   * @param {Morphology} morpho - raw object that describes a morphology (usually straight from a JSON file)\n   * @param {object} options - the option object\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   */\n  constructor(morpho, options) {\n    super(morpho, options)\n    const sections = this._morpho.getArrayOfSections()\n\n    // creating a polyline for each section\n    for (let i = 0; i < sections.length; i += 1) {\n      const sectionPolyline = this._buildSection(sections[i])\n      this.add(sectionPolyline)\n    }\n\n    // adding the soma mesh, but sometimes, there is no soma\n    const somaData = this._morpho.getSoma()\n    if (somaData) {\n      const somaShape = this._buildSoma(options)\n      this.add(somaShape)\n    }\n\n    // this is because the Allen ref is not oriented the same way as WebGL\n    this.rotateX(Math.PI)\n    this.rotateY(Math.PI)\n\n    // compute the bounding box, useful for further camera targeting\n    this.box = new THREE.Box3().setFromObject(this)\n  }\n\n\n  /**\n   * @private\n   * Builds a single section from a raw segment description and returns it.\n   * A section is usually composed of multiple segments\n   * @param {Section} section - sub part of the morpho raw object thar deals with a single section\n   * @return {THREE.Line} the constructed polyline\n   */\n  _buildSection(section) {\n    const material = new THREE.LineBasicMaterial({\n      color: this._sectionColors[section.getTypename()],\n    })\n\n    const sectionPoints = section.getPoints()\n    const geometry = new THREE.Geometry()\n\n    for (let i = 0; i < sectionPoints.length; i += 1) {\n      geometry.vertices.push(new THREE.Vector3(\n        sectionPoints[i][0], // x\n        sectionPoints[i][1], // y\n        sectionPoints[i][2], // z\n      ))\n    }\n\n    const line = new THREE.Line(geometry, material)\n\n    // adding some metadata as it can be useful for raycasting\n    line.name = section.getId()\n    line.userData.sectionId = section.getId()\n    line.userData.typevalue = section.getTypevalue()\n    line.userData.typename = section.getTypename()\n\n    return line\n  }\n}\n\n\nexport default MorphologyPolyline\n","/*\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport * as THREE from 'three'\n\nconst BufferGeometryUtils = {\n\n  computeTangents(geometry) {\n    const index = geometry.index\n    const attributes = geometry.attributes\n\n    // based on http://www.terathon.com/code/tangent.html\n    // (per vertex tangents)\n\n    if (index === null\n       || attributes.position === undefined\n       || attributes.normal === undefined\n       || attributes.uv === undefined) {\n      console.warn('THREE.BufferGeometry: Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()')\n      return\n    }\n\n    const indices = index.array\n    const positions = attributes.position.array\n    const normals = attributes.normal.array\n    const uvs = attributes.uv.array\n\n    const nVertices = positions.length / 3\n\n    if (attributes.tangent === undefined) {\n      geometry.addAttribute('tangent', new THREE.BufferAttribute(new Float32Array(4 * nVertices), 4))\n    }\n\n    const tangents = attributes.tangent.array\n\n    const tan1 = []; const\n      tan2 = []\n\n    for (var i = 0; i < nVertices; i++) {\n      tan1[i] = new THREE.Vector3()\n      tan2[i] = new THREE.Vector3()\n    }\n\n    const vA = new THREE.Vector3()\n\n\n    const vB = new THREE.Vector3()\n\n\n    const vC = new THREE.Vector3()\n\n\n    const uvA = new THREE.Vector2()\n\n\n    const uvB = new THREE.Vector2()\n\n\n    const uvC = new THREE.Vector2()\n\n\n    const sdir = new THREE.Vector3()\n\n\n    const tdir = new THREE.Vector3()\n\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3)\n      vB.fromArray(positions, b * 3)\n      vC.fromArray(positions, c * 3)\n\n      uvA.fromArray(uvs, a * 2)\n      uvB.fromArray(uvs, b * 2)\n      uvC.fromArray(uvs, c * 2)\n\n      const x1 = vB.x - vA.x\n      const x2 = vC.x - vA.x\n\n      const y1 = vB.y - vA.y\n      const y2 = vC.y - vA.y\n\n      const z1 = vB.z - vA.z\n      const z2 = vC.z - vA.z\n\n      const s1 = uvB.x - uvA.x\n      const s2 = uvC.x - uvA.x\n\n      const t1 = uvB.y - uvA.y\n      const t2 = uvC.y - uvA.y\n\n      const r = 1.0 / (s1 * t2 - s2 * t1)\n\n      sdir.set(\n        (t2 * x1 - t1 * x2) * r,\n        (t2 * y1 - t1 * y2) * r,\n        (t2 * z1 - t1 * z2) * r,\n      )\n\n      tdir.set(\n        (s1 * x2 - s2 * x1) * r,\n        (s1 * y2 - s2 * y1) * r,\n        (s1 * z2 - s2 * z1) * r,\n      )\n\n      tan1[a].add(sdir)\n      tan1[b].add(sdir)\n      tan1[c].add(sdir)\n\n      tan2[a].add(tdir)\n      tan2[b].add(tdir)\n      tan2[c].add(tdir)\n    }\n\n    let groups = geometry.groups\n\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length,\n      }]\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i]\n\n      var start = group.start\n      var count = group.count\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(\n          indices[j + 0],\n          indices[j + 1],\n          indices[j + 2],\n        )\n      }\n    }\n\n    const tmp = new THREE.Vector3(); const\n      tmp2 = new THREE.Vector3()\n    const n = new THREE.Vector3(); const\n      n2 = new THREE.Vector3()\n    let w; let t; let\n      test\n\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3)\n      n2.copy(n)\n\n      t = tan1[v]\n\n      // Gram-Schmidt orthogonalize\n\n      tmp.copy(t)\n      tmp.sub(n.multiplyScalar(n.dot(t))).normalize()\n\n      // Calculate handedness\n\n      tmp2.crossVectors(n2, t)\n      test = tmp2.dot(tan2[v])\n      w = (test < 0.0) ? -1.0 : 1.0\n\n      tangents[v * 4] = tmp.x\n      tangents[v * 4 + 1] = tmp.y\n      tangents[v * 4 + 2] = tmp.z\n      tangents[v * 4 + 3] = w\n    }\n\n    for (var i = 0, il = groups.length; i < il; ++i) {\n      var group = groups[i]\n\n      var start = group.start\n      var count = group.count\n\n      for (var j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0])\n        handleVertex(indices[j + 1])\n        handleVertex(indices[j + 2])\n      }\n    }\n  },\n\n  /**\n   * @param  {Array<THREE.BufferGeometry>} geometries\n   * @return {THREE.BufferGeometry}\n   */\n  mergeBufferGeometries(geometries, useGroups) {\n    const isIndexed = geometries[0].index !== null\n\n    const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n    const attributes = {}\n    const morphAttributes = {}\n\n    const mergedGeometry = new THREE.BufferGeometry()\n\n    let offset = 0\n\n    for (var i = 0; i < geometries.length; ++i) {\n      const geometry = geometries[i]\n\n      // ensure that all geometries are indexed, or none\n\n      if (isIndexed !== (geometry.index !== null)) return null\n\n      // gather attributes, exit early if they're different\n\n      for (var name in geometry.attributes) {\n        if (!attributesUsed.has(name)) return null\n\n        if (attributes[name] === undefined) attributes[name] = []\n\n        attributes[name].push(geometry.attributes[name])\n      }\n\n      // gather morph attributes, exit early if they're different\n\n      for (var name in geometry.morphAttributes) {\n        if (!morphAttributesUsed.has(name)) return null\n\n        if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n        morphAttributes[name].push(geometry.morphAttributes[name])\n      }\n\n      // gather .userData\n\n      mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n      mergedGeometry.userData.mergedUserData.push(geometry.userData)\n\n      if (useGroups) {\n        var count\n\n        if (isIndexed) {\n          count = geometry.index.count\n        } else if (geometry.attributes.position !== undefined) {\n          count = geometry.attributes.position.count\n        } else {\n          return null\n        }\n\n        mergedGeometry.addGroup(offset, count, i)\n\n        offset += count\n      }\n    }\n\n    // merge indices\n\n    if (isIndexed) {\n      let indexOffset = 0\n      const mergedIndex = []\n\n      for (var i = 0; i < geometries.length; ++i) {\n        const index = geometries[i].index\n\n        for (var j = 0; j < index.count; ++j) {\n          mergedIndex.push(index.getX(j) + indexOffset)\n        }\n\n        indexOffset += geometries[i].attributes.position.count\n      }\n\n      mergedGeometry.setIndex(mergedIndex)\n    }\n\n    // merge attributes\n\n    for (var name in attributes) {\n      const mergedAttribute = this.mergeBufferAttributes(attributes[name])\n\n      if (!mergedAttribute) return null\n\n      mergedGeometry.addAttribute(name, mergedAttribute)\n    }\n\n    // merge morph attributes\n\n    for (var name in morphAttributes) {\n      const numMorphTargets = morphAttributes[name][0].length\n\n      if (numMorphTargets === 0) break\n\n      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n      mergedGeometry.morphAttributes[name] = []\n\n      for (var i = 0; i < numMorphTargets; ++i) {\n        const morphAttributesToMerge = []\n\n        for (var j = 0; j < morphAttributes[name].length; ++j) {\n          morphAttributesToMerge.push(morphAttributes[name][j][i])\n        }\n\n        const mergedMorphAttribute = this.mergeBufferAttributes(morphAttributesToMerge)\n\n        if (!mergedMorphAttribute) return null\n\n        mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n      }\n    }\n\n    return mergedGeometry\n  },\n\n  /**\n   * @param {Array<THREE.BufferAttribute>} attributes\n   * @return {THREE.BufferAttribute}\n   */\n  mergeBufferAttributes(attributes) {\n    let TypedArray\n    let itemSize\n    let normalized\n    let arrayLength = 0\n\n    for (var i = 0; i < attributes.length; ++i) {\n      const attribute = attributes[i]\n\n      if (attribute.isInterleavedBufferAttribute) return null\n\n      if (TypedArray === undefined) TypedArray = attribute.array.constructor\n      if (TypedArray !== attribute.array.constructor) return null\n\n      if (itemSize === undefined) itemSize = attribute.itemSize\n      if (itemSize !== attribute.itemSize) return null\n\n      if (normalized === undefined) normalized = attribute.normalized\n      if (normalized !== attribute.normalized) return null\n\n      arrayLength += attribute.array.length\n    }\n\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    for (var i = 0; i < attributes.length; ++i) {\n      array.set(attributes[i].array, offset)\n\n      offset += attributes[i].array.length\n    }\n\n    return new THREE.BufferAttribute(array, itemSize, normalized)\n  },\n\n}\n\n\nexport default BufferGeometryUtils\n","import * as THREE from 'three'\nimport Tools from './Tools'\nimport MorphologyShapeBase from './MorphologyShapeBase'\nimport BufferGeometryUtils from './thirdparty/BufferGeometryUtils'\n\n\n/**\n * The MorphologyPolycylinder is a tubular representation of a morphology, using cylinders.\n * this alternative to MorphologyPolyline is heavier on CPU and GPU so is more made when\n * displaying a small number of morphologies.\n * MorphologyPolycylinder extends from THREE.Object so that it's easy to integrate.\n * It's constructor\n */\nclass MorphologyPolycylinder extends MorphologyShapeBase {\n  /**\n   * @constructor\n   * Builds a moprho as a polyline\n   * @param {Object} morpho - raw object that describes a morphology (usually straight from a JSON file)\n   * @param {object} options - the option object\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   */\n  constructor(morpho, options) {\n    super(morpho, options)\n\n    this._sectionTubeMaterials = {\n      axon: new THREE.MeshPhongMaterial({ color: this._sectionColors.axon }),\n      basal_dendrite: new THREE.MeshPhongMaterial({ color: this._sectionColors.basal_dendrite }),\n      apical_dendrite: new THREE.MeshPhongMaterial({ color: this._sectionColors.apical_dendrite }),\n    }\n\n    const sections = this._morpho.getArrayOfSections()\n\n    // creating a polyline for each section\n    for (let i = 0; i < sections.length; i += 1) {\n      const section = this._buildSection(sections[i])\n      if (section) this.add(section)\n    }\n\n    // adding the soma, but sometimes, there is no soma data...\n    const somaData = this._morpho.getSoma()\n    if (somaData) {\n      const somaShape = this._buildSoma(options)\n      this.add(somaShape)\n    }\n\n    // this is because the Allen ref is not oriented the same way as WebGL\n    this.rotateX(Math.PI)\n    this.rotateY(Math.PI)\n\n    // compute the bounding box, useful for further camera targeting\n    this.box = new THREE.Box3().setFromObject(this)\n  }\n\n\n  /**\n   * @private\n   * Builds a single section from a raw segment description and returns it.\n   * A section is usually composed of multiple segments\n   * @param {Section} sectionDescription - sub part of the morpho raw object thar deals with a single section\n   * @return {THREE.Line} the constructed polyline\n   */\n  _buildSection(section) {\n    const material = this._sectionTubeMaterials[section.getTypename()]\n    const sectionPoints = section.getPoints()\n    const sectionRadius = section.getRadiuses()\n    const startIndex = section.getParent() ? 0 : 1\n\n    if ((sectionPoints.length - startIndex) < 2) return null\n\n    const arrayOfGeom = []\n\n    for (let i = startIndex; i < sectionPoints.length - 1; i += 1) {\n      const cyl = Tools.makeCylinder(\n        new THREE.Vector3( // vStart\n          sectionPoints[i][0],\n          sectionPoints[i][1],\n          sectionPoints[i][2],\n        ),\n        new THREE.Vector3( // vEnd\n          sectionPoints[i + 1][0],\n          sectionPoints[i + 1][1],\n          sectionPoints[i + 1][2],\n        ),\n        sectionRadius[i], // rStart\n        sectionRadius[i + 1], // rEnd\n        false, // openEnd\n      )\n      arrayOfGeom.push(cyl)\n    }\n\n    // merging the buffer geometries to make things faster\n    const sectionGeom = BufferGeometryUtils.mergeBufferGeometries(arrayOfGeom)\n    const sectionMesh = new THREE.Mesh(sectionGeom, material)\n\n    // adding some metadata as it can be useful for raycasting\n    sectionMesh.name = section.getId()\n    sectionMesh.userData.sectionId = section.getId()\n    sectionMesh.userData.typevalue = section.getTypevalue()\n    sectionMesh.userData.typename = section.getTypename()\n\n    return sectionMesh\n  }\n}\n\nexport default MorphologyPolycylinder\n","import morphologycorejs from 'morphologycorejs';\nimport ThreeContext from './ThreeContext';\nimport MorphologyPolyline from './MorphologyPolyline';\nimport MorphologyPolycylinder from './MorphologyPolycylinder';\nimport Tools from './Tools';\n\n/**\n * The MorphoViewer class is the entry point object of the MorphoViewer project\n * and is the only object the user should be dealing with.\n */\nclass MorphoViewer {\n  constructor(canvas) {\n    this._threeContext = new ThreeContext(canvas)\n  }\n\n  /**\n   * Add a morphology to the collection so that it displays.\n   * @param {Object|morphologycorejs.Morphology} morphoObj - describes the morphology of a neuron.\n   * This data comes straight from the JSON file or it can also be a Morphology object from `morphologycorejs`\n   * @param {object} options - the optional values\n   * @param {String} options.name - The name to give to this morphology. Will be used as an identifier for several operations\n   * @param {Boolean} options.asPolyline - if true: shows a polyline view. false: shows a tubular view (default: true)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added morphology. If false, the camera will not change\n   * @param {Number} options.color - the color of the polyline.\n   * If provided, the whole neurone will be of the given color, if not provided,\n   * the axon will be green, the basal dendrite will be red and the apical dendrite will be green\n   * @param {String} options.somaMode - \"default\" to display only the soma data or \"fromOrphanSections\" to build a soma using the orphan sections\n   * @param {Function} options.onDone - callback when the morphology is displayed. Called with the name (given or generated) of the morphology\n   * @param {Number} options.distance - the distance between the camera and the soma. Only relevant if `onFocus` is `true`\n   */\n  addMorphology(morphoObj, options) {\n    // create a morphology object from the raw object\n    let morphology = null\n\n    // creates an auto name if none is giver\n    options.name = Tools.getOption(\n      options,\n      'name',\n      `morpho_${Math.round(Math.random() * 1000000).toString()}`,\n    )\n\n    if (morphoObj instanceof morphologycorejs.Morphology) {\n      morphology = morphoObj\n    } else {\n      morphology = new morphologycorejs.Morphology()\n      morphology.buildFromRawMorphology(morphoObj)\n    }\n\n    morphology.setId(options.name)\n\n    const asPolyline = Tools.getOption(options, 'asPolyline', true)\n\n    if (asPolyline) {\n      const morphoPolyLine = new MorphologyPolyline(morphology, options)\n      this._threeContext.addMorphology(morphoPolyLine, options)\n    } else {\n      const morpho = new MorphologyPolycylinder(morphology, options)\n      this._threeContext.addMorphology(morpho, options)\n    }\n  }\n\n  /**\n   * Adds a mesh from its URL. The mesh has to encoded into the STL format\n   * @param {String} url - the url of the STL file\n   * @param {Object} options - the options object\n   * @param {String} options.name - optional name of this mesh (useful for further operations such as centering the view)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added mesh. If false, the camera will not change\n   * @param {Number} options.opacity - the opacity of the mesh\n   * @param {Number} options.color - the color of the mesh\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Function} options.onDone - callback to be called when the mesh is added. Called with the name of the mesh in argument\n   */\n  addStlToMeshCollection(url, options) {\n    this._threeContext.addStlToMeshCollection(url, options)\n  }\n\n  /**\n   * Kill all to save up memory, stop the annimation, removes events, delete the canvas\n   */\n  destroy() {\n    this._threeContext.destroy()\n  }\n\n  /**\n   * Get the field of view angle of the camera, in degrees\n   * @return {Number}\n   */\n  getCameraFieldOfView() {\n    return this._threeContext.getCameraFieldOfView()\n  }\n\n  /**\n   * Define the camera field of view, in degrees\n   * @param {Number} fov - the fov\n   */\n  setCameraFieldOfView(fov) {\n    this._threeContext.setCameraFieldOfView(fov)\n  }\n\n  /**\n   * Make the camera look at the soma of a morphology (or the center of it's bounding box\n   * if the neuron does not have soma data)\n   * @param {String} name - the name of the neuron to focus on\n   * @param {Number} distance - distance from the soma center (in world space, most likely microns)\n   */\n  focusOnMorphology(name, distance) {\n    this._threeContext.focusOnMorphology(name, distance)\n  }\n\n  /**\n   * Make the camera focus on the given mesh\n   * @param {String} name - name of the mesh\n   */\n  focusOnMesh(name) {\n    this._threeContext.focusOnMesh(name)\n  }\n\n  /**\n   * Define a callback associated with clicking on a section. The callback function\n   * is called with the `morphologycorejs.Section` instance as arguments (or `undefined`)\n   */\n  onRaycast(cb) {\n    this._threeContext.on('onRaycast', cb)\n  }\n\n  /**\n   * Take a screenshot of the webgl context and dowload the png image\n   * @param {String} filename - name under which we want to dowload this file (optional)\n   */\n  takeScreenshot(filename = 'capture.png') {\n    const imageData = this._threeContext.getSnapshotData()\n    return imageData\n    // Tools.triggerDownload(imageData, filename)\n  }\n\n  /**\n   * Adds a OBJ mesh to the scene\n   * @param {String} objStr - the string from the OBJ file\n   * @param {Object} options - the options object\n   * @param {String} options.name - optional name of this mesh (useful for further operations such as centering the view)\n   * @param {Boolean} options.focusOn - if true, the camera will focus on this added mesh. If false, the camera will not change\n   * @param {Number} options.opacity - the opacity of the mesh\n   * @param {Number} options.color - the color of the mesh\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Number} options.wireframe - only the wireframe will display if true. If false, the regular mesh will show\n   * @param {Function} options.onDone - callback to be called when the mesh is added. Called with the name of the mesh in argument\n   */\n  addObjToMeshCollection(objStr, options) {\n    this._threeContext.addObjToMeshCollection(objStr, options)\n  }\n\n  /**\n   * Show the given mesh from the colelction\n   * @param {String} name - Name of the mesh\n   */\n  showMesh(name) {\n    this._threeContext.showMesh(name)\n  }\n\n  /**\n   * Hide the given mesh from the colelction\n   * @param {String} name - Name of the mesh\n   */\n  hideMesh(name) {\n    this._threeContext.hideMesh(name)\n  }\n}\n\nexport default MorphoViewer\n","import MorphoViewer from './MorphoViewer'\n\nexport default ({\n  MorphoViewer,\n})\n"],"names":["THREE.DefaultLoadingManager","THREE.FileLoader","THREE.BufferGeometry","THREE.BufferAttribute","THREE.Vector3","THREE.Float32BufferAttribute","THREE.LoaderUtils","THREE.Matrix4","THREE.CylinderBufferGeometry","canvas","THREE.PerspectiveCamera","THREE.Scene","THREE.AmbientLight","THREE.DirectionalLight","THREE.CanvasRenderer","THREE.Raycaster","THREE.Vector2","THREE.Mesh","THREE.MeshPhongMaterial","THREE.DoubleSide","THREE.FrontSide","THREE.Line3","THREE.Plane","THREE.Triangle","THREE.Geometry","THREE.Object3D","THREE.SphereGeometry","THREE.Face3","THREE.MeshBasicMaterial","THREE.Box3","THREE.LineBasicMaterial","THREE.Line"],"mappings":"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"}